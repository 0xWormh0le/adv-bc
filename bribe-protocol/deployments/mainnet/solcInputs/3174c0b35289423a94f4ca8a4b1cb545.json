{
  "language": "Solidity",
  "sources": {
    "contracts/AavePool.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IAaveGovernanceV2} from \"./interfaces/Aave/IAaveGovernanceV2.sol\";\nimport {IGovernanceStrategy} from \"./interfaces/Aave/IGovernanceStrategy.sol\";\nimport \"./interfaces/IAavePool.sol\";\nimport \"./interfaces/IWrapperToken.sol\";\nimport \"./interfaces/Aave/IStakedAave.sol\";\nimport \"./interfaces/IERC20Details.sol\";\nimport \"./interfaces/IBribeExecutor.sol\";\nimport \"./BribePoolBase.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n///\n/// @title AavePool\n/// @author contact@bribe.xyz\n/// @notice\n///\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract AavePool is BribePoolBase, IAavePool, Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    /// @dev share scale\n    uint256 private constant SHARE_SCALE = 1e12;\n\n    /// @dev maximum claim iterations\n    uint64 internal constant MAX_CLAIM_ITERATIONS = 10;\n\n    /// @dev fee precision\n    uint64 internal constant FEE_PRECISION = 10000;\n\n    /// @dev fee percentage share is 16%\n    uint128 internal constant FEE_PERCENTAGE = 1600;\n\n    /// @dev seconds per block\n    uint64 internal constant secondPerBlock = 13;\n\n    /// @dev aave governance\n    address public immutable aaveGovernance;\n\n    /// @dev bidders will bid with bidAsset e.g. usdc\n    IERC20 public immutable bidAsset;\n\n    /// @dev bribe token\n    IERC20 public immutable bribeToken;\n\n    /// @dev aave token\n    IERC20 public immutable aaveToken;\n\n    /// @dev stkAave token\n    IERC20 public immutable stkAaveToken;\n\n    /// @dev aave wrapper token\n    IWrapperToken public immutable wrapperAaveToken;\n\n    /// @dev stkAave wrapper token\n    IWrapperToken public immutable wrapperStkAaveToken;\n\n    /// @dev feeReceipient address to send received fees to\n    address public feeReceipient;\n\n    /// @dev pending rewards to be distributed\n    uint128 internal pendingRewardToBeDistributed;\n\n    /// @dev fees received\n    uint128 public feesReceived;\n\n    /// @dev asset index\n    AssetIndex public assetIndex;\n\n    /// @dev bribre reward config\n    BribeReward public bribeRewardConfig;\n\n    /// @dev bid id to bid information\n    mapping(uint256 => Bid) public bids;\n\n    /// @dev blocked proposals\n    mapping(uint256 => bool) public blockedProposals;\n\n    /// @dev proposal id to bid information\n    mapping(uint256 => uint256) internal bidIdToProposalId;\n\n    /// @dev user info\n    mapping(address => UserInfo) internal users;\n\n    constructor(\n        address bribeToken_,\n        address aaveToken_,\n        address stkAaveToken_,\n        address bidAsset_,\n        address aave_,\n        address feeReceipient_,\n        IWrapperToken wrapperAaveToken_,\n        IWrapperToken wrapperStkAaveToken_,\n        BribeReward memory rewardConfig_\n    ) BribePoolBase() {\n        require(bribeToken_ != address(0), \"BRIBE_TOKEN\");\n        require(aaveToken_ != address(0), \"AAVE_TOKEN\");\n        require(stkAaveToken_ != address(0), \"STKAAVE_TOKEN\");\n        require(aave_ != address(0), \"AAVE_GOVERNANCE\");\n        require(address(bidAsset_) != address(0), \"BID_ASSET\");\n        require(feeReceipient_ != address(0), \"FEE_RECEIPIENT\");\n        require(address(wrapperAaveToken_) != address(0), \"AAVE_WRAPPER\");\n        require(address(wrapperStkAaveToken_) != address(0), \"STK_WRAPPER\");\n\n        bribeToken = IERC20(bribeToken_);\n        aaveToken = IERC20(aaveToken_);\n        stkAaveToken = IERC20(stkAaveToken_);\n        aaveGovernance = aave_;\n        bidAsset = IERC20(bidAsset_);\n        bribeRewardConfig = rewardConfig_;\n        feeReceipient = feeReceipient_;\n\n        // initialize wrapper tokens\n        wrapperAaveToken_.initialize(aaveToken_);\n        wrapperStkAaveToken_.initialize(stkAaveToken_);\n\n        wrapperAaveToken = wrapperAaveToken_;\n        wrapperStkAaveToken = wrapperStkAaveToken_;\n    }\n\n    /// @notice deposit\n    /// @param asset either Aave or stkAave\n    /// @param recipient address to mint the receipt tokens\n    /// @param amount amount of tokens to deposit\n    /// @param claim claim stk aave rewards from Aave\n    function deposit(\n        IERC20 asset,\n        address recipient,\n        uint128 amount,\n        bool claim\n    ) external override whenNotPaused nonReentrant {\n        if (asset == aaveToken) {\n            _deposit(asset, wrapperAaveToken, recipient, amount, claim);\n        } else {\n            _deposit(stkAaveToken, wrapperStkAaveToken, recipient, amount, claim);\n        }\n    }\n\n    /// @notice withdraw\n    /// @param asset either Aave or stkAave\n    /// @param recipient address to mint the receipt tokens\n    /// @param amount amount of tokens to deposit\n    /// @param claim claim stk aave rewards from Aave\n    function withdraw(\n        IERC20 asset,\n        address recipient,\n        uint128 amount,\n        bool claim\n    ) external override nonReentrant {\n        if (asset == aaveToken) {\n            _withdraw(asset, wrapperAaveToken, recipient, amount, claim);\n        } else {\n            _withdraw(stkAaveToken, wrapperStkAaveToken, recipient, amount, claim);\n        }\n    }\n\n    /// @dev vote to `proposalId` with `support` option\n    /// @param proposalId proposal id\n    function vote(uint256 proposalId) external nonReentrant {\n        Bid storage currentBid = bids[proposalId];\n\n        require(currentBid.endTime > 0, \"INVALID_PROPOSAL\");\n        require(currentBid.endTime < block.timestamp, \"BID_ACTIVE\");\n\n        distributeRewards(proposalId);\n\n        IAaveGovernanceV2(aaveGovernance).submitVote(proposalId, currentBid.support);\n\n        emit Vote(proposalId, msg.sender, currentBid.support, block.timestamp);\n    }\n\n    /// @dev place a bid after check AaveGovernance status\n    /// @param bidder bidder address\n    /// @param proposalId proposal id\n    /// @param amount amount of bid assets\n    /// @param support the suport for the proposal\n    function bid(\n        address bidder,\n        uint256 proposalId,\n        uint128 amount,\n        bool support\n    ) external override whenNotPaused nonReentrant {\n        IAaveGovernanceV2.ProposalState state = IAaveGovernanceV2(aaveGovernance).getProposalState(\n            proposalId\n        );\n        require(\n            state == IAaveGovernanceV2.ProposalState.Pending ||\n                state == IAaveGovernanceV2.ProposalState.Active,\n            \"INVALID_PROPOSAL_STATE\"\n        );\n\n        require(blockedProposals[proposalId] == false, \"PROPOSAL_BLOCKED\");\n\n        Bid storage currentBid = bids[proposalId];\n        address prevHighestBidder = currentBid.highestBidder;\n        uint128 currentHighestBid = currentBid.highestBid;\n        uint128 newHighestBid;\n\n        // new bid\n        if (prevHighestBidder == address(0)) {\n            uint64 endTime = uint64(_getAuctionExpiration(proposalId));\n            currentBid.endTime = endTime;\n            currentBid.totalVotes = votingPower(proposalId);\n            currentBid.proposalStartBlock = IAaveGovernanceV2(aaveGovernance)\n                .getProposalById(proposalId)\n                .startBlock;\n        }\n\n        require(currentBid.endTime > block.timestamp, \"BID_ENDED\");\n        require(currentBid.totalVotes > 0, \"INVALID_VOTING_POWER\");\n\n        // if bidder == currentHighestBidder increase the bid amount\n        if (prevHighestBidder == bidder) {\n            bidAsset.safeTransferFrom(msg.sender, address(this), amount);\n\n            newHighestBid = currentHighestBid + amount;\n        } else {\n            require(amount > currentHighestBid, \"LOW_BID\");\n\n            bidAsset.safeTransferFrom(msg.sender, address(this), amount);\n\n            // refund to previous highest bidder\n            if (prevHighestBidder != address(0)) {\n                pendingRewardToBeDistributed -= currentHighestBid;\n                bidAsset.safeTransfer(prevHighestBidder, currentHighestBid);\n            }\n\n            newHighestBid = amount;\n        }\n\n        // write the new bid info to storage\n        pendingRewardToBeDistributed += amount;\n        currentBid.highestBid = newHighestBid;\n        currentBid.support = support;\n        currentBid.highestBidder = bidder;\n\n        emit HighestBidIncreased(\n            proposalId,\n            prevHighestBidder,\n            bidder,\n            msg.sender,\n            newHighestBid,\n            support\n        );\n    }\n\n    /// @dev refund bid for a cancelled proposal ONLY if it was not voted on\n    /// @param proposalId proposal id\n    function refund(uint256 proposalId) external nonReentrant {\n        IAaveGovernanceV2.ProposalState state = IAaveGovernanceV2(aaveGovernance).getProposalState(\n            proposalId\n        );\n\n        require(state == IAaveGovernanceV2.ProposalState.Canceled, \"PROPOSAL_ACTIVE\");\n\n        Bid storage currentBid = bids[proposalId];\n        uint128 highestBid = currentBid.highestBid;\n        address highestBidder = currentBid.highestBidder;\n\n        // we do not refund if no high bid or if the proposal has been voted on\n        if (highestBid == 0 || currentBid.voted) return;\n\n        // reset the bid proposal state\n        delete bids[proposalId];\n\n        // refund the bid money\n        pendingRewardToBeDistributed -= highestBid;\n        bidAsset.safeTransfer(highestBidder, highestBid);\n\n        emit Refund(proposalId, highestBidder, highestBid);\n    }\n\n    /// @dev distribute rewards for the proposal\n    /// @notice called in children's vote function (after bidding process ended)\n    /// @param proposalId id of proposal to distribute rewards fo\n    function distributeRewards(uint256 proposalId) public {\n        Bid storage currentBid = bids[proposalId];\n\n        // ensure that the bidding period has ended\n        require(block.timestamp > currentBid.endTime, \"BID_ACTIVE\");\n\n        if (currentBid.voted) return;\n\n        uint128 highestBid = currentBid.highestBid;\n        uint128 feeAmount = _calculateFeeAmount(highestBid);\n\n        // reduce pending reward\n        pendingRewardToBeDistributed -= highestBid;\n        assetIndex.bidIndex += (highestBid - feeAmount);\n        feesReceived += feeAmount;\n        currentBid.voted = true;\n        // rewrite the highest bid minus fee\n        // set and increase the bid id\n        bidIdToProposalId[assetIndex.bidId] = proposalId;\n        assetIndex.bidId += 1;\n\n        emit RewardDistributed(proposalId, highestBid);\n    }\n\n    /// @dev withdrawFees withdraw fees\n    /// Enables ONLY the fee receipient to withdraw the pool accrued fees\n    function withdrawFees() external override nonReentrant returns (uint256 feeAmount) {\n        require(msg.sender == feeReceipient, \"ONLY_RECEIPIENT\");\n\n        feeAmount = feesReceived;\n\n        if (feeAmount > 0) {\n            feesReceived = 0;\n            bidAsset.safeTransfer(feeReceipient, feeAmount);\n        }\n\n        emit WithdrawFees(address(this), feeAmount, block.timestamp);\n    }\n\n    /// @dev get reward amount for user specified by `user`\n    /// @param user address of user to check balance of\n    function rewardBalanceOf(address user)\n        external\n        view\n        returns (\n            uint256 totalPendingBidReward,\n            uint256 totalPendingStkAaveReward,\n            uint256 totalPendingBribeReward\n        )\n    {\n        uint256 userAaveBalance = wrapperAaveToken.balanceOf(user);\n        uint256 userStkAaveBalance = wrapperStkAaveToken.balanceOf(user);\n        uint256 pendingBribeReward = _userPendingBribeReward(\n            userAaveBalance + userStkAaveBalance,\n            users[user].bribeLastRewardPerShare,\n            _calculateBribeRewardPerShare(_calculateBribeRewardIndex())\n        );\n\n        uint256 pendingBidReward;\n\n        uint256 currentBidRewardCount = assetIndex.bidId;\n\n        if (userAaveBalance > 0) {\n            pendingBidReward += _calculateUserPendingBidRewards(\n                wrapperAaveToken,\n                user,\n                users[user].aaveLastBidId,\n                currentBidRewardCount\n            );\n        }\n\n        if (userStkAaveBalance > 0) {\n            pendingBidReward += _calculateUserPendingBidRewards(\n                wrapperStkAaveToken,\n                user,\n                users[user].stkAaveLastBidId,\n                currentBidRewardCount\n            );\n        }\n\n        totalPendingBidReward = users[user].totalPendingBidReward + pendingBidReward;\n        (uint128 rewardsToReceive, ) = _stkAaveRewardsToReceive();\n\n        totalPendingStkAaveReward =\n            users[user].totalPendingStkAaveReward +\n            _userPendingstkAaveRewards(\n                user,\n                users[user].stkAaveLastRewardPerShare,\n                _calculateStkAaveRewardPerShare(rewardsToReceive),\n                wrapperStkAaveToken\n            );\n        totalPendingBribeReward = users[user].totalPendingBribeReward + pendingBribeReward;\n    }\n\n    /// @dev claimReward for msg.sender\n    /// @param to address to send the rewards to\n    /// @param executor An external contract to call with\n    /// @param data data to call the executor contract\n    /// @param claim claim stk aave rewards from Aave\n    function claimReward(\n        address to,\n        IBribeExecutor executor,\n        bytes calldata data,\n        bool claim\n    ) external whenNotPaused nonReentrant {\n        // accrue rewards for both stkAave and Aave token balances\n        _accrueRewards(msg.sender, claim);\n\n        UserInfo storage _currentUser = users[msg.sender];\n\n        uint128 pendingBid = _currentUser.totalPendingBidReward;\n        uint128 pendingStkAaveReward = _currentUser.totalPendingStkAaveReward;\n        uint128 pendingBribeReward = _currentUser.totalPendingBribeReward;\n\n        unchecked {\n            // reset the reward calculation\n            _currentUser.totalPendingBidReward = 0;\n            _currentUser.totalPendingStkAaveReward = 0;\n            // update lastStkAaveRewardBalance\n            assetIndex.lastStkAaveRewardBalance -= pendingStkAaveReward;\n        }\n\n        if (pendingBid > 0) {\n            bidAsset.safeTransfer(to, pendingBid);\n        }\n\n        if (pendingStkAaveReward > 0 && claim) {\n            // claim stk aave rewards\n            IStakedAave(address(stkAaveToken)).claimRewards(to, pendingStkAaveReward);\n        }\n\n        if (pendingBribeReward > 0 && bribeToken.balanceOf(address(this)) > pendingBribeReward) {\n            _currentUser.totalPendingBribeReward = 0;\n\n            if (address(executor) != address(0)) {\n                bribeToken.safeTransfer(address(executor), pendingBribeReward);\n                executor.execute(msg.sender, pendingBribeReward, data);\n            } else {\n                require(to != address(0), \"INVALID_ADDRESS\");\n                bribeToken.safeTransfer(to, pendingBribeReward);\n            }\n        }\n\n        emit RewardClaim(\n            msg.sender,\n            pendingBid,\n            pendingStkAaveReward,\n            pendingBribeReward,\n            block.timestamp\n        );\n    }\n\n    /// @dev block a proposalId from used in the pool\n    /// @param proposalId proposalId\n    function blockProposalId(uint256 proposalId) external onlyOwner {\n        require(blockedProposals[proposalId] == false, \"PROPOSAL_INACTIVE\");\n        Bid storage currentBid = bids[proposalId];\n\n        // check if the propoal has already been voted on\n        require(currentBid.voted == false, \"BID_DISTRIBUTED\");\n\n        blockedProposals[proposalId] = true;\n\n        uint128 highestBid = currentBid.highestBid;\n\n        // check if the proposalId has any bids\n        // if there is any current highest bidder\n        // and the reward has not been distributed refund the bidder\n        if (highestBid > 0) {\n            pendingRewardToBeDistributed -= highestBid;\n            address highestBidder = currentBid.highestBidder;\n            // reset the bids\n            delete bids[proposalId];\n            bidAsset.safeTransfer(highestBidder, highestBid);\n        }\n\n        emit BlockProposalId(proposalId, block.timestamp);\n    }\n\n    /// @dev unblock a proposalId from used in the pool\n    /// @param proposalId proposalId\n    function unblockProposalId(uint256 proposalId) external onlyOwner {\n        require(blockedProposals[proposalId] == true, \"PROPOSAL_ACTIVE\");\n\n        blockedProposals[proposalId] = false;\n\n        emit UnblockProposalId(proposalId, block.timestamp);\n    }\n\n    /// @dev returns the pool voting power for a proposal\n    /// @param proposalId proposalId to fetch pool voting power\n    function votingPower(uint256 proposalId) public view returns (uint256 power) {\n        IAaveGovernanceV2.ProposalWithoutVotes memory proposal = IAaveGovernanceV2(aaveGovernance)\n            .getProposalById(proposalId);\n        address governanceStrategy = IAaveGovernanceV2(aaveGovernance).getGovernanceStrategy();\n        power = IGovernanceStrategy(governanceStrategy).getVotingPowerAt(\n            address(this),\n            proposal.startBlock\n        );\n    }\n\n    /// @dev getPendingRewardToBeDistributed returns the pending reward to be distributed\n    /// minus fees\n    function getPendingRewardToBeDistributed() external view returns (uint256 pendingReward) {\n        pendingReward =\n            pendingRewardToBeDistributed -\n            _calculateFeeAmount(pendingRewardToBeDistributed);\n    }\n\n    /// @notice pause pool actions\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice unpause pool actions\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /// @notice setFeeRecipient\n    /// @param newReceipient new fee receipeitn\n    function setFeeRecipient(address newReceipient) external onlyOwner {\n        require(newReceipient != address(0), \"INVALID_RECIPIENT\");\n\n        feeReceipient = newReceipient;\n\n        emit UpdateFeeRecipient(address(this), newReceipient);\n    }\n\n    /// @notice setStartTimestamp\n    /// @param startTimestamp when to start distributing rewards\n    /// @param rewardPerSecond reward to distribute per second\n    function setStartTimestamp(uint64 startTimestamp, uint128 rewardPerSecond) external onlyOwner {\n        require(startTimestamp > block.timestamp, \"INVALID_START_TIMESTAMP\");\n        if (bribeRewardConfig.endTimestamp != 0) {\n            require(startTimestamp < bribeRewardConfig.endTimestamp, \"HIGH_TIMESTAMP\");\n        }\n\n        _updateBribeRewardIndex();\n\n        uint64 oldTimestamp = bribeRewardConfig.startTimestamp;\n        bribeRewardConfig.startTimestamp = startTimestamp;\n\n        _setRewardPerSecond(rewardPerSecond);\n\n        emit SetBribeRewardStartTimestamp(oldTimestamp, startTimestamp);\n    }\n\n    /// @notice setEndTimestamp\n    /// @param endTimestamp end of bribe rewards\n    function setEndTimestamp(uint64 endTimestamp) external onlyOwner {\n        require(endTimestamp > block.timestamp, \"INVALID_END_TIMESTAMP\");\n        require(endTimestamp > bribeRewardConfig.startTimestamp, \"LOW_TIMESTAMP\");\n\n        _updateBribeRewardIndex();\n\n        uint64 oldTimestamp = bribeRewardConfig.endTimestamp;\n        bribeRewardConfig.endTimestamp = endTimestamp;\n\n        emit SetBribeRewardEndTimestamp(oldTimestamp, endTimestamp);\n    }\n\n    /// @notice setEndTimestamp\n    /// @param rewardPerSecond amount of rewards to distribute per second\n    function setRewardPerSecond(uint128 rewardPerSecond) public onlyOwner {\n        _updateBribeRewardIndex();\n        _setRewardPerSecond(rewardPerSecond);\n    }\n\n    function _setRewardPerSecond(uint128 rewardPerSecond) internal {\n        require(rewardPerSecond > 0, \"INVALID_REWARD_SECOND\");\n\n        uint128 oldReward = bribeRewardConfig.rewardAmountDistributedPerSecond;\n\n        bribeRewardConfig.rewardAmountDistributedPerSecond = rewardPerSecond;\n\n        emit SetBribeRewardPerSecond(oldReward, rewardPerSecond);\n    }\n\n    /// @notice withdrawRemainingBribeReward\n    /// @dev there is a 30 days window period after endTimestamp where a user can claim\n    /// rewards before it can be reclaimed by Bribe\n    function withdrawRemainingBribeReward() external onlyOwner {\n        require(bribeRewardConfig.endTimestamp != 0, \"INVALID_END_TIMESTAMP\");\n        require(block.timestamp > bribeRewardConfig.endTimestamp + 30 days, \"GRACE_PERIOD\");\n\n        uint256 remaining = bribeToken.balanceOf(address(this));\n\n        bribeToken.safeTransfer(address(this), remaining);\n\n        emit WithdrawRemainingReward(remaining);\n    }\n\n    /// @dev  _calculateFeeAmount calculate the fee percentage share\n    function _calculateFeeAmount(uint128 amount) internal pure returns (uint128 feeAmount) {\n        feeAmount = (amount * FEE_PERCENTAGE) / FEE_PRECISION;\n    }\n\n    struct NewUserRewardInfoLocalVars {\n        uint256 pendingBidReward;\n        uint256 pendingstkAaveReward;\n        uint256 pendingBribeReward;\n        uint256 newUserAaveBidId;\n        uint256 newUserStAaveBidId;\n    }\n\n    /// @dev _accrueRewards accrue rewards for an address\n    /// @param user address to accrue rewards for\n    /// @param claim claim pending stk aave rewards\n    function _accrueRewards(address user, bool claim) internal {\n        require(user != address(0), \"INVALID_ADDRESS\");\n\n        UserInfo storage _user = users[user];\n\n        NewUserRewardInfoLocalVars memory userRewardVars;\n\n        uint256 userAaveBalance = wrapperAaveToken.balanceOf(user);\n        uint256 userStkAaveBalance = wrapperStkAaveToken.balanceOf(user);\n        uint256 total = userAaveBalance + userStkAaveBalance;\n\n        // update bribe reward index\n        _updateBribeRewardIndex();\n\n        if (total > 0) {\n            // calculate updated bribe rewards\n            userRewardVars.pendingBribeReward = _userPendingBribeReward(\n                total,\n                _user.bribeLastRewardPerShare,\n                assetIndex.bribeRewardPerShare\n            );\n        }\n\n        if (userAaveBalance > 0) {\n            // calculate pendingBidRewards\n            uint256 reward;\n            (userRewardVars.newUserAaveBidId, reward) = _userPendingBidRewards(\n                assetIndex.bidIndex,\n                wrapperAaveToken,\n                user,\n                users[user].aaveLastBidId\n            );\n            userRewardVars.pendingBidReward += reward;\n        }\n\n        if (claim) {\n            _updateStkAaveStakeReward();\n        }\n\n        if (userStkAaveBalance > 0) {\n            // calculate pendingBidRewards\n            uint256 reward;\n            (userRewardVars.newUserStAaveBidId, reward) = _userPendingBidRewards(\n                assetIndex.bidIndex,\n                wrapperStkAaveToken,\n                user,\n                users[user].stkAaveLastBidId\n            );\n            userRewardVars.pendingBidReward += reward;\n\n            // distribute stkAaveTokenRewards to the user too\n            userRewardVars.pendingstkAaveReward = _userPendingstkAaveRewards(\n                user,\n                users[user].stkAaveLastRewardPerShare,\n                assetIndex.stkAaveRewardPerShare,\n                wrapperStkAaveToken\n            );\n        }\n\n        // write to storage\n        _user.totalPendingBribeReward += userRewardVars.pendingBribeReward.toUint128();\n        _user.totalPendingBidReward += userRewardVars.pendingBidReward.toUint128();\n        _user.totalPendingStkAaveReward += userRewardVars.pendingstkAaveReward.toUint128();\n        _user.stkAaveLastRewardPerShare = assetIndex.stkAaveRewardPerShare;\n        _user.bribeLastRewardPerShare = assetIndex.bribeRewardPerShare;\n        _user.aaveLastBidId = userRewardVars.newUserAaveBidId.toUint128();\n        _user.stkAaveLastBidId = userRewardVars.newUserStAaveBidId.toUint128();\n\n        emit RewardAccrue(\n            user,\n            userRewardVars.pendingBidReward,\n            userRewardVars.pendingstkAaveReward,\n            userRewardVars.pendingBribeReward,\n            block.timestamp\n        );\n    }\n\n    /// @dev deposit governance token\n    /// @param asset asset to withdraw\n    /// @param receiptToken asset wrapper token\n    /// @param recipient address to award the receipt tokens\n    /// @param amount amount to deposit\n    /// @param claim claim pending stk aave rewards\n    /// @notice emit {Deposit} event\n    function _deposit(\n        IERC20 asset,\n        IWrapperToken receiptToken,\n        address recipient,\n        uint128 amount,\n        bool claim\n    ) internal {\n        require(amount > 0, \"INVALID_AMOUNT\");\n\n        // accrue user pending rewards\n        _accrueRewards(recipient, claim);\n\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n\n        // performs check that recipient != address(0)\n        receiptToken.mint(recipient, amount);\n\n        emit Deposit(asset, recipient, amount, block.timestamp);\n    }\n\n    /// @dev withdraw governance token\n    /// @param asset asset to withdraw\n    /// @param receiptToken asset wrapper token\n    /// @param recipient address to award the receipt tokens\n    /// @param amount amount to withdraw\n    /// @param claim claim pending stk aave rewards\n    function _withdraw(\n        IERC20 asset,\n        IWrapperToken receiptToken,\n        address recipient,\n        uint128 amount,\n        bool claim\n    ) internal {\n        require(amount > 0, \"INVALID_AMOUNT\");\n        require(receiptToken.balanceOf(msg.sender) >= amount, \"INVALID_BALANCE\");\n\n        // claim pending bid rewards only\n        _accrueRewards(msg.sender, claim);\n\n        // burn tokens\n        receiptToken.burn(msg.sender, amount);\n\n        // send back tokens\n        asset.safeTransfer(recipient, amount);\n\n        emit Withdraw(asset, msg.sender, amount, block.timestamp);\n    }\n\n    /// @dev _calculateBribeRewardIndex\n    function _calculateBribeRewardIndex() internal view returns (uint256 amount) {\n        if (\n            bribeRewardConfig.startTimestamp == 0 ||\n            bribeRewardConfig.startTimestamp > block.timestamp\n        ) return 0;\n\n        uint64 startTimestamp = (bribeRewardConfig.startTimestamp >\n            assetIndex.bribeLastRewardTimestamp)\n            ? bribeRewardConfig.startTimestamp\n            : assetIndex.bribeLastRewardTimestamp;\n\n        uint256 endTimestamp;\n\n        if (bribeRewardConfig.endTimestamp == 0) {\n            endTimestamp = block.timestamp;\n        } else {\n            endTimestamp = block.timestamp > bribeRewardConfig.endTimestamp\n                ? bribeRewardConfig.endTimestamp\n                : block.timestamp;\n        }\n\n        if (endTimestamp > startTimestamp) {\n            amount =\n                (endTimestamp - startTimestamp) *\n                bribeRewardConfig.rewardAmountDistributedPerSecond;\n        }\n    }\n\n    /// @dev _updateBribeRewardIndex\n    function _updateBribeRewardIndex() internal {\n        uint256 newRewardAmount = _calculateBribeRewardIndex();\n\n        assetIndex.bribeLastRewardTimestamp = block.timestamp.toUint64();\n        assetIndex.bribeRewardIndex += newRewardAmount.toUint128();\n        assetIndex.bribeRewardPerShare = _calculateBribeRewardPerShare(newRewardAmount).toUint128();\n\n        emit AssetReward(bribeToken, assetIndex.bribeRewardIndex, block.timestamp);\n    }\n\n    /// @dev _calculateBribeRewardPerShare\n    /// @param newRewardAmount additional reward\n    function _calculateBribeRewardPerShare(uint256 newRewardAmount)\n        internal\n        view\n        returns (uint256 newBribeRewardPerShare)\n    {\n        uint256 increaseSharePrice;\n        if (newRewardAmount > 0) {\n            increaseSharePrice = ((newRewardAmount * SHARE_SCALE) / _totalSupply());\n        }\n\n        newBribeRewardPerShare = assetIndex.bribeRewardPerShare + increaseSharePrice;\n    }\n\n    /// @dev _userPendingBribeReward\n    /// @param userBalance user aave + stkAave balance\n    /// @param userLastPricePerShare user last price per share\n    /// @param currentBribeRewardPerShare current reward per share\n    function _userPendingBribeReward(\n        uint256 userBalance,\n        uint256 userLastPricePerShare,\n        uint256 currentBribeRewardPerShare\n    ) internal pure returns (uint256 pendingReward) {\n        if (userBalance > 0 && currentBribeRewardPerShare > 0) {\n            pendingReward = ((userBalance * (currentBribeRewardPerShare - userLastPricePerShare)) /\n                SHARE_SCALE).toUint128();\n        }\n    }\n\n    /// @dev _totalSupply current total supply of tokens\n    function _totalSupply() internal view returns (uint256) {\n        return wrapperAaveToken.totalSupply() + wrapperStkAaveToken.totalSupply();\n    }\n\n    /// @dev returns the user bid reward share\n    /// @param receiptToken wrapper token\n    /// @param user user\n    /// @param userLastBidId user last bid id\n    function _userPendingBidRewards(\n        uint128 currentBidIndex,\n        IWrapperToken receiptToken,\n        address user,\n        uint128 userLastBidId\n    ) internal view returns (uint256 accrueBidId, uint256 totalPendingReward) {\n        if (currentBidIndex == 0) return (0, 0);\n\n        uint256 currentBidRewardCount = assetIndex.bidId;\n\n        if (userLastBidId == currentBidRewardCount) return (currentBidRewardCount, 0);\n\n        accrueBidId = (currentBidRewardCount - userLastBidId) <= MAX_CLAIM_ITERATIONS\n            ? currentBidRewardCount\n            : userLastBidId + MAX_CLAIM_ITERATIONS;\n\n        totalPendingReward = _calculateUserPendingBidRewards(\n            receiptToken,\n            user,\n            userLastBidId,\n            accrueBidId\n        );\n    }\n\n    /// @dev _calculateUserPendingBidRewards\n    /// @param receiptToken wrapper token\n    /// @param user user\n    /// @param userLastBidId user last bid id\n    /// @param maxRewardId maximum bid id to accrue rewards to\n    function _calculateUserPendingBidRewards(\n        IWrapperToken receiptToken,\n        address user,\n        uint256 userLastBidId,\n        uint256 maxRewardId\n    ) internal view returns (uint256 totalPendingReward) {\n        for (uint256 i = userLastBidId; i < maxRewardId; i++) {\n            uint256 proposalId = bidIdToProposalId[i];\n            Bid storage _bid = bids[proposalId];\n            uint128 highestBid = _bid.highestBid;\n            // only calculate if highest bid is available and it has been distributed\n            if (highestBid > 0 && _bid.voted) {\n                uint256 amount = receiptToken.getDepositAt(user, _bid.proposalStartBlock);\n                if (amount > 0) {\n                    // subtract fee from highest bid\n                    totalPendingReward +=\n                        (amount * (highestBid - _calculateFeeAmount(highestBid))) /\n                        _bid.totalVotes;\n                }\n            }\n        }\n    }\n\n    /// @dev update the stkAAve aave reward index\n    function _updateStkAaveStakeReward() internal {\n        (uint128 rewardsToReceive, uint256 newBalance) = _stkAaveRewardsToReceive();\n        if (rewardsToReceive == 0) return;\n\n        assetIndex.rewardIndex += rewardsToReceive;\n        assetIndex.stkAaveRewardPerShare = _calculateStkAaveRewardPerShare(rewardsToReceive);\n        assetIndex.lastStkAaveRewardBalance = newBalance;\n\n        emit AssetReward(aaveToken, assetIndex.rewardIndex, block.timestamp);\n    }\n\n    /// @dev _calculateStkAaveRewardPerShare\n    /// @param rewardsToReceive amount of aave rewards to receive\n    function _calculateStkAaveRewardPerShare(uint256 rewardsToReceive)\n        internal\n        view\n        returns (uint128 newRewardPerShare)\n    {\n        uint256 increaseRewardSharePrice;\n        if (rewardsToReceive > 0) {\n            increaseRewardSharePrice = ((rewardsToReceive * SHARE_SCALE) /\n                wrapperStkAaveToken.totalSupply());\n        }\n\n        newRewardPerShare = (assetIndex.stkAaveRewardPerShare + increaseRewardSharePrice)\n            .toUint128();\n    }\n\n    /// @dev _stkAaveRewardsToReceive\n    function _stkAaveRewardsToReceive()\n        internal\n        view\n        returns (uint128 rewardsToReceive, uint256 newBalance)\n    {\n        newBalance = IStakedAave(address(stkAaveToken)).getTotalRewardsBalance(address(this));\n        rewardsToReceive = newBalance.toUint128() - assetIndex.lastStkAaveRewardBalance.toUint128();\n    }\n\n    /// @dev get the user stkAave aave reward share\n    /// @param user user address\n    /// @param userLastPricePerShare userLastPricePerShare\n    /// @param currentStkAaveRewardPerShare the latest reward per share\n    /// @param receiptToken stak aave wrapper token\n    function _userPendingstkAaveRewards(\n        address user,\n        uint128 userLastPricePerShare,\n        uint128 currentStkAaveRewardPerShare,\n        IWrapperToken receiptToken\n    ) internal view returns (uint256 pendingReward) {\n        uint256 userBalance = receiptToken.balanceOf(user);\n\n        if (userBalance > 0 && currentStkAaveRewardPerShare > 0) {\n            uint128 rewardDebt = ((userBalance * userLastPricePerShare) / SHARE_SCALE).toUint128();\n            pendingReward = (((userBalance * currentStkAaveRewardPerShare) / SHARE_SCALE) -\n                rewardDebt).toUint128();\n        }\n    }\n\n    /// @dev get auction expiration of `proposalId`\n    /// @param proposalId proposal id\n    function _getAuctionExpiration(uint256 proposalId) internal view returns (uint256) {\n        IAaveGovernanceV2.ProposalWithoutVotes memory proposal = IAaveGovernanceV2(aaveGovernance)\n            .getProposalById(proposalId);\n        return block.timestamp + (proposal.endBlock - block.number) * secondPerBlock - 1 hours;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/Aave/IAaveGovernanceV2.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\npragma abicoder v2;\n\nimport {IExecutorWithTimelock} from \"./IExecutorWithTimelock.sol\";\n\ninterface IAaveGovernanceV2 {\n    enum ProposalState {\n        Pending,\n        Canceled,\n        Active,\n        Failed,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    struct Vote {\n        bool support;\n        uint248 votingPower;\n    }\n\n    struct Proposal {\n        uint256 id;\n        address creator;\n        IExecutorWithTimelock executor;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        bool[] withDelegatecalls;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 executionTime;\n        uint256 forVotes;\n        uint256 againstVotes;\n        bool executed;\n        bool canceled;\n        address strategy;\n        bytes32 ipfsHash;\n        mapping(address => Vote) votes;\n    }\n\n    struct ProposalWithoutVotes {\n        uint256 id;\n        address creator;\n        IExecutorWithTimelock executor;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        bool[] withDelegatecalls;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 executionTime;\n        uint256 forVotes;\n        uint256 againstVotes;\n        bool executed;\n        bool canceled;\n        address strategy;\n        bytes32 ipfsHash;\n    }\n\n    /**\n     * @dev emitted when a new proposal is created\n     * @param id Id of the proposal\n     * @param creator address of the creator\n     * @param executor The ExecutorWithTimelock contract that will execute the proposal\n     * @param targets list of contracts called by proposal's associated transactions\n     * @param values list of value in wei for each propoposal's associated transaction\n     * @param signatures list of function signatures (can be empty) to be used when created the callData\n     * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\n     * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\n     * @param startBlock block number when vote starts\n     * @param endBlock block number when vote ends\n     * @param strategy address of the governanceStrategy contract\n     * @param ipfsHash IPFS hash of the proposal\n     **/\n    event ProposalCreated(\n        uint256 id,\n        address indexed creator,\n        IExecutorWithTimelock indexed executor,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        bool[] withDelegatecalls,\n        uint256 startBlock,\n        uint256 endBlock,\n        address strategy,\n        bytes32 ipfsHash\n    );\n\n    /**\n     * @dev emitted when a proposal is canceled\n     * @param id Id of the proposal\n     **/\n    event ProposalCanceled(uint256 id);\n\n    /**\n     * @dev emitted when a proposal is queued\n     * @param id Id of the proposal\n     * @param executionTime time when proposal underlying transactions can be executed\n     * @param initiatorQueueing address of the initiator of the queuing transaction\n     **/\n    event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\n    /**\n     * @dev emitted when a proposal is executed\n     * @param id Id of the proposal\n     * @param initiatorExecution address of the initiator of the execution transaction\n     **/\n    event ProposalExecuted(uint256 id, address indexed initiatorExecution);\n    /**\n     * @dev emitted when a vote is registered\n     * @param id Id of the proposal\n     * @param voter address of the voter\n     * @param support boolean, true = vote for, false = vote against\n     * @param votingPower Power of the voter/vote\n     **/\n    event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\n\n    event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\n\n    event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\n\n    event ExecutorAuthorized(address executor);\n\n    event ExecutorUnauthorized(address executor);\n\n    /**\n     * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\n     * @param executor The ExecutorWithTimelock contract that will execute the proposal\n     * @param targets list of contracts called by proposal's associated transactions\n     * @param values list of value in wei for each propoposal's associated transaction\n     * @param signatures list of function signatures (can be empty) to be used when created the callData\n     * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\n     * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\n     * @param ipfsHash IPFS hash of the proposal\n     **/\n    function create(\n        IExecutorWithTimelock executor,\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        bool[] memory withDelegatecalls,\n        bytes32 ipfsHash\n    ) external returns (uint256);\n\n    /**\n     * @dev Cancels a Proposal,\n     * either at anytime by guardian\n     * or when proposal is Pending/Active and threshold no longer reached\n     * @param proposalId id of the proposal\n     **/\n    function cancel(uint256 proposalId) external;\n\n    /**\n     * @dev Queue the proposal (If Proposal Succeeded)\n     * @param proposalId id of the proposal to queue\n     **/\n    function queue(uint256 proposalId) external;\n\n    /**\n     * @dev Execute the proposal (If Proposal Queued)\n     * @param proposalId id of the proposal to execute\n     **/\n    function execute(uint256 proposalId) external payable;\n\n    /**\n     * @dev Function allowing msg.sender to vote for/against a proposal\n     * @param proposalId id of the proposal\n     * @param support boolean, true = vote for, false = vote against\n     **/\n    function submitVote(uint256 proposalId, bool support) external;\n\n    /**\n     * @dev Function to register the vote of user that has voted offchain via signature\n     * @param proposalId id of the proposal\n     * @param support boolean, true = vote for, false = vote against\n     * @param v v part of the voter signature\n     * @param r r part of the voter signature\n     * @param s s part of the voter signature\n     **/\n    function submitVoteBySignature(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Set new GovernanceStrategy\n     * Note: owner should be a timelocked executor, so needs to make a proposal\n     * @param governanceStrategy new Address of the GovernanceStrategy contract\n     **/\n    function setGovernanceStrategy(address governanceStrategy) external;\n\n    /**\n     * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\n     * Note: owner should be a timelocked executor, so needs to make a proposal\n     * @param votingDelay new voting delay in seconds\n     **/\n    function setVotingDelay(uint256 votingDelay) external;\n\n    /**\n     * @dev Add new addresses to the list of authorized executors\n     * @param executors list of new addresses to be authorized executors\n     **/\n    function authorizeExecutors(address[] memory executors) external;\n\n    /**\n     * @dev Remove addresses to the list of authorized executors\n     * @param executors list of addresses to be removed as authorized executors\n     **/\n    function unauthorizeExecutors(address[] memory executors) external;\n\n    /**\n     * @dev Let the guardian abdicate from its priviledged rights\n     **/\n    function __abdicate() external;\n\n    /**\n     * @dev Getter of the current GovernanceStrategy address\n     * @return The address of the current GovernanceStrategy contracts\n     **/\n    function getGovernanceStrategy() external view returns (address);\n\n    /**\n     * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\n     * Different from the voting duration\n     * @return The voting delay in seconds\n     **/\n    function getVotingDelay() external view returns (uint256);\n\n    /**\n     * @dev Returns whether an address is an authorized executor\n     * @param executor address to evaluate as authorized executor\n     * @return true if authorized\n     **/\n    function isExecutorAuthorized(address executor) external view returns (bool);\n\n    /**\n     * @dev Getter the address of the guardian, that can mainly cancel proposals\n     * @return The address of the guardian\n     **/\n    function getGuardian() external view returns (address);\n\n    /**\n     * @dev Getter of the proposal count (the current number of proposals ever created)\n     * @return the proposal count\n     **/\n    function getProposalsCount() external view returns (uint256);\n\n    /**\n     * @dev Getter of a proposal by id\n     * @param proposalId id of the proposal to get\n     * @return the proposal as ProposalWithoutVotes memory object\n     **/\n    function getProposalById(uint256 proposalId)\n        external\n        view\n        returns (ProposalWithoutVotes memory);\n\n    /**\n     * @dev Getter of the Vote of a voter about a proposal\n     * Note: Vote is a struct: ({bool support, uint248 votingPower})\n     * @param proposalId id of the proposal\n     * @param voter address of the voter\n     * @return The associated Vote memory object\n     **/\n    function getVoteOnProposal(uint256 proposalId, address voter)\n        external\n        view\n        returns (Vote memory);\n\n    /**\n     * @dev Get the current state of a proposal\n     * @param proposalId id of the proposal\n     * @return The current state if the proposal\n     **/\n    function getProposalState(uint256 proposalId) external view returns (ProposalState);\n}\n"
    },
    "contracts/interfaces/Aave/IGovernanceStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\npragma abicoder v2;\n\ninterface IGovernanceStrategy {\n    /**\n     * @dev Returns the Proposition Power of a user at a specific block number.\n     * @param user Address of the user.\n     * @param blockNumber Blocknumber at which to fetch Proposition Power\n     * @return Power number\n     **/\n    function getPropositionPowerAt(address user, uint256 blockNumber)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns the total supply of Outstanding Proposition Tokens\n     * @param blockNumber Blocknumber at which to evaluate\n     * @return total supply at blockNumber\n     **/\n    function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of Outstanding Voting Tokens\n     * @param blockNumber Blocknumber at which to evaluate\n     * @return total supply at blockNumber\n     **/\n    function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the Vote Power of a user at a specific block number.\n     * @param user Address of the user.\n     * @param blockNumber Blocknumber at which to fetch Vote Power\n     * @return Vote number\n     **/\n    function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAavePool.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IAavePool {\n    struct AssetIndex {\n        // tracks the last stkAave aave reward balance\n        uint256 lastStkAaveRewardBalance;\n        // tracks the total Aave reward for stkAave holders\n        uint128 rewardIndex;\n        // bribe reward index;\n        uint128 bribeRewardIndex;\n        // bribe reward last timestamp\n        uint64 bribeLastRewardTimestamp;\n        // bid id\n        uint64 bidId;\n        // tracks the total bid reward\n        // share to be distributed\n        uint128 bidIndex;\n        // tracks the reward per share\n        uint128 bribeRewardPerShare;\n        // tracks the reward per share\n        uint128 stkAaveRewardPerShare;\n    }\n\n    struct BribeReward {\n        uint128 rewardAmountDistributedPerSecond;\n        uint64 startTimestamp;\n        uint64 endTimestamp;\n    }\n\n    struct UserInfo {\n        // stkaave reward index\n        uint128 stkAaveLastRewardPerShare;\n        // bribe reward index\n        uint128 bribeLastRewardPerShare;\n        // reward from the bids in the bribe pool\n        uint128 totalPendingBidReward;\n        // tracks aave reward from the stk aave pool\n        uint128 totalPendingStkAaveReward;\n        // tracks bribe distributed to the user\n        uint128 totalPendingBribeReward;\n        // tracks the last user bid id for aave deposit\n        uint128 aaveLastBidId;\n        // tracks the last user bid id for stkAave deposit\n        uint128 stkAaveLastBidId;\n    }\n\n    /// @dev proposal bid info\n    struct Bid {\n        uint256 totalVotes;\n        uint256 proposalStartBlock;\n        uint128 highestBid;\n        uint64 endTime;\n        bool support;\n        bool voted;\n        address highestBidder;\n    }\n\n    /// @dev emitted on deposit\n    event Deposit(IERC20 indexed token, address indexed user, uint256 amount, uint256 timestamp);\n\n    /// @dev emitted on user reward accrue\n    event AssetReward(IERC20 indexed asset, uint256 totalAmountAccrued, uint256 timestamp);\n\n    /// @dev emitted on user reward accrue\n    event RewardAccrue(\n        address indexed user,\n        uint256 pendingBidReward,\n        uint256 pendingStkAaveReward,\n        uint256 pendingBribeReward,\n        uint256 timestamp\n    );\n\n    event Withdraw(IERC20 indexed token, address indexed user, uint256 amount, uint256 timestamp);\n\n    event RewardClaim(\n        address indexed user,\n        uint256 pendingBid,\n        uint256 pendingReward,\n        uint256 pendingBribeReward,\n        uint256 timestamp\n    );\n\n    event RewardDistributed(uint256 proposalId, uint256 amount);\n\n    event HighestBidIncreased(\n        uint256 indexed proposalId,\n        address indexed prevHighestBidder,\n        address indexed highestBidder,\n        address sender,\n        uint256 highestBid,\n        bool support\n    );\n\n    event BlockProposalId(uint256 indexed proposalId, uint256 timestamp);\n\n    event UnblockProposalId(uint256 indexed proposalId, uint256 timestamp);\n\n    event UpdateDelayPeriod(uint256 delayperiod, uint256 timestamp);\n\n    /// @dev emitted on vote\n    event Vote(uint256 indexed proposalId, address user, bool support, uint256 timestamp);\n\n    /// @dev emitted on Refund\n    event Refund(uint256 indexed proposalId, address bidder, uint256 bidAmount);\n\n    /// @dev emitted on Unclaimed rewards\n    event UnclaimedRewards(address owner, uint256 amount);\n\n    /// @dev emitted on setEndTimestamp\n    event SetBribeRewardEndTimestamp(uint256 oldTimestamp, uint256 endTimestamp);\n\n    /// @dev emitted on setRewardPerSecond\n    event SetBribeRewardPerSecond(uint256 oldRewardPerSecond, uint256 newRewardPerSecond);\n\n    /// @dev emitted on withdrawRemainingReward\n    event WithdrawRemainingReward(uint256 amount);\n\n    /// @dev emmitted on setStartTimestamp\n    event SetBribeRewardStartTimestamp(uint256 oldTimestamp, uint256 endTimestamp);\n\n    /// @dev emitted on setFeeRecipient\n    event UpdateFeeRecipient(address sender, address receipient);\n\n    function deposit(\n        IERC20 asset,\n        address recipient,\n        uint128 amount,\n        bool claim\n    ) external;\n\n    function withdraw(\n        IERC20 asset,\n        address recipient,\n        uint128 amount,\n        bool claim\n    ) external;\n\n    function bid(\n        address bidder,\n        uint256 proposalId,\n        uint128 amount,\n        bool support\n    ) external;\n}\n"
    },
    "contracts/interfaces/IWrapperToken.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IWrapperToken is IERC20Upgradeable {\n    function mint(address, uint256) external;\n\n    function burn(address, uint256) external;\n\n    function getAccountSnapshot(address user)\n        external\n        view\n        returns (uint256[] memory, uint256[] memory);\n\n    function getDepositAt(address user, uint256 blockNumber) external view returns (uint256 amount);\n\n    function initialize(address underlying_) external;\n\n    /// @dev emitted on update account snapshot\n    event UpdateSnapshot(\n        address indexed user,\n        uint256 oldValue,\n        uint256 newValue,\n        uint256 timestamp\n    );\n}\n"
    },
    "contracts/interfaces/Aave/IStakedAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStakedAave is IERC20 {\n    function claimRewards(address to, uint256 amount) external;\n\n    function getTotalRewardsBalance(address staker) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC20Details.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IERC20Details {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IBribeExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IBribeExecutor {\n    function execute(\n        address user,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/BribePoolBase.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"./interfaces/Bribe/IBribeMultiAssetPool.sol\";\nimport \"./interfaces/IFeeDistributor.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n///\n/// @title BribePoolBase\n/// @author contact@bribe.xyz\n/// @notice\n///\n////////////////////////////////////////////////////////////////////////////////////////////\n\nabstract contract BribePoolBase is IBribeMultiAssetPool, IFeeDistributor, Ownable, Multicall {\n    constructor() Ownable() {}\n\n    /// @notice Call wrapper that performs `ERC20.permit` on `token`.\n    //  Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\n    function permitToken(\n        IERC20Permit token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        token.permit(from, to, amount, deadline, v, r, s);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/Aave/IExecutorWithTimelock.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.4;\npragma abicoder v2;\n\nimport {IAaveGovernanceV2} from \"./IAaveGovernanceV2.sol\";\n\ninterface IExecutorWithTimelock {\n    /**\n     * @dev emitted when a new pending admin is set\n     * @param newPendingAdmin address of the new pending admin\n     **/\n    event NewPendingAdmin(address newPendingAdmin);\n\n    /**\n     * @dev emitted when a new admin is set\n     * @param newAdmin address of the new admin\n     **/\n    event NewAdmin(address newAdmin);\n\n    /**\n     * @dev emitted when a new delay (between queueing and execution) is set\n     * @param delay new delay\n     **/\n    event NewDelay(uint256 delay);\n\n    /**\n     * @dev emitted when a new (trans)action is Queued.\n     * @param actionHash hash of the action\n     * @param target address of the targeted contract\n     * @param value wei value of the transaction\n     * @param signature function signature of the transaction\n     * @param data function arguments of the transaction or callData if signature empty\n     * @param executionTime time at which to execute the transaction\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n     **/\n    event QueuedAction(\n        bytes32 actionHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 executionTime,\n        bool withDelegatecall\n    );\n\n    /**\n     * @dev emitted when an action is Cancelled\n     * @param actionHash hash of the action\n     * @param target address of the targeted contract\n     * @param value wei value of the transaction\n     * @param signature function signature of the transaction\n     * @param data function arguments of the transaction or callData if signature empty\n     * @param executionTime time at which to execute the transaction\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n     **/\n    event CancelledAction(\n        bytes32 actionHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 executionTime,\n        bool withDelegatecall\n    );\n\n    /**\n     * @dev emitted when an action is Cancelled\n     * @param actionHash hash of the action\n     * @param target address of the targeted contract\n     * @param value wei value of the transaction\n     * @param signature function signature of the transaction\n     * @param data function arguments of the transaction or callData if signature empty\n     * @param executionTime time at which to execute the transaction\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n     * @param resultData the actual callData used on the target\n     **/\n    event ExecutedAction(\n        bytes32 actionHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 executionTime,\n        bool withDelegatecall,\n        bytes resultData\n    );\n\n    /**\n     * @dev Getter of the current admin address (should be governance)\n     * @return The address of the current admin\n     **/\n    function getAdmin() external view returns (address);\n\n    /**\n     * @dev Getter of the current pending admin address\n     * @return The address of the pending admin\n     **/\n    function getPendingAdmin() external view returns (address);\n\n    /**\n     * @dev Getter of the delay between queuing and execution\n     * @return The delay in seconds\n     **/\n    function getDelay() external view returns (uint256);\n\n    /**\n     * @dev Returns whether an action (via actionHash) is queued\n     * @param actionHash hash of the action to be checked\n     * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\n     * @return true if underlying action of actionHash is queued\n     **/\n    function isActionQueued(bytes32 actionHash) external view returns (bool);\n\n    /**\n     * @dev Checks whether a proposal is over its grace period\n     * @param governance Governance contract\n     * @param proposalId Id of the proposal against which to test\n     * @return true of proposal is over grace period\n     **/\n    function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Getter of grace period constant\n     * @return grace period in seconds\n     **/\n    function GRACE_PERIOD() external view returns (uint256);\n\n    /**\n     * @dev Getter of minimum delay constant\n     * @return minimum delay in seconds\n     **/\n    function MINIMUM_DELAY() external view returns (uint256);\n\n    /**\n     * @dev Getter of maximum delay constant\n     * @return maximum delay in seconds\n     **/\n    function MAXIMUM_DELAY() external view returns (uint256);\n\n    /**\n     * @dev Function, called by Governance, that queue a transaction, returns action hash\n     * @param target smart contract target\n     * @param value wei value of the transaction\n     * @param signature function signature of the transaction\n     * @param data function arguments of the transaction or callData if signature empty\n     * @param executionTime time at which to execute the transaction\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n     **/\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 executionTime,\n        bool withDelegatecall\n    ) external returns (bytes32);\n\n    /**\n     * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\n     * @param target smart contract target\n     * @param value wei value of the transaction\n     * @param signature function signature of the transaction\n     * @param data function arguments of the transaction or callData if signature empty\n     * @param executionTime time at which to execute the transaction\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n     **/\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 executionTime,\n        bool withDelegatecall\n    ) external payable returns (bytes memory);\n\n    /**\n     * @dev Function, called by Governance, that cancels a transaction, returns action hash\n     * @param target smart contract target\n     * @param value wei value of the transaction\n     * @param signature function signature of the transaction\n     * @param data function arguments of the transaction or callData if signature empty\n     * @param executionTime time at which to execute the transaction\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n     **/\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 executionTime,\n        bool withDelegatecall\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/Bribe/IBribeMultiAssetPool.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBribeMultiAssetPool {}\n"
    },
    "contracts/interfaces/IFeeDistributor.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IFeeDistributor {\n    ////\n    /// fee distribution interface to be implemented\n    /// by all pools so that they conform to the\n    /// fee Distributor implementation\n    ///\n\n    event WithdrawFees(address indexed sender, uint256 feesReceived, uint256 timestamp);\n\n    function withdrawFees() external returns (uint256 feeAmount);\n}\n"
    },
    "contracts/FeeDistribution.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IFeeDistributor.sol\";\nimport \"./interfaces/IFeeDistribution.sol\";\nimport \"hardhat/console.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n///\n/// @title FeeDistribution\n/// @author contact@bribe.xyz\n/// @notice\n///\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract FeeDistribution is IFeeDistribution, Ownable, Pausable {\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 private constant SHARE_SCALE = 1e12;\n\n    /// @dev fee asset\n    IERC20 public immutable feeAsset;\n\n    /// @dev fee receiver to distribution configuration\n    mapping(address => FeeReceiver) public feeReceiverData;\n\n    /// @dev total distribution allocation points\n    uint128 public totalAllocPoints;\n\n    /// @dev total fees received\n    uint128 public totalFeesReceived;\n\n    /// @dev price peer share\n    uint256 public pricePerShare;\n\n    constructor(IERC20 feeAsset_) Ownable() {\n        require(address(feeAsset_) != address(0), \"INVALID_FEE_ASSET\");\n        feeAsset = feeAsset_;\n    }\n\n    /// @dev setFeeReceivers\n    /// @param receivers address to send fees\n    /// @param allocPoints address alloc point\n    function setFeeReceivers(address[] calldata receivers, uint128[] calldata allocPoints)\n        external\n        onlyOwner\n    {\n        require(receivers.length == allocPoints.length, \"INVALID_SIZE\");\n\n        uint256 size = receivers.length;\n\n        for (uint256 i = 0; i < size; i++) {\n            address receiver = receivers[i];\n            uint128 newAllocPoint = allocPoints[i];\n            uint256 currentAllocPoint = feeReceiverData[receiver].allocPoint;\n            _accrue(receiver);\n            _setFeeReceiver(receiver, newAllocPoint);\n\n            emit SetFeeReceiver(receiver, currentAllocPoint, newAllocPoint);\n        }\n    }\n\n    /// @dev rescueFunds\n    /// @notice Allows the owner to rescue funds in the contract\n    function rescueFunds(address to) external onlyOwner {\n        uint256 amount = feeAsset.balanceOf(address(this));\n        if (amount > 0) {\n            feeAsset.safeTransfer(to, amount);\n            emit RescueFunds(address(this), amount);\n        }\n    }\n\n    /// @dev claimFees\n    /// @param pools pools to claim fees from\n    function claimFees(IFeeDistributor[] calldata pools) external whenNotPaused {\n        uint256 size = pools.length;\n        uint256 prevBalance = feeAsset.balanceOf(address(this));\n\n        uint256 receivedFees;\n        for (uint256 i = 0; i < size; i++) {\n            receivedFees += pools[i].withdrawFees().toUint128();\n        }\n\n        // assert that the fees was transferred\n        require(feeAsset.balanceOf(address(this)) - prevBalance >= receivedFees, \"INVALID_CLAIM\");\n\n        totalFeesReceived += receivedFees.toUint128();\n\n        require(totalAllocPoints > 0, \"NO_RECEIVERS\");\n\n        pricePerShare += (receivedFees * SHARE_SCALE) / totalAllocPoints;\n\n        emit ClaimFees(receivedFees, totalFeesReceived);\n    }\n\n    function _accrue(address receiver) internal {\n        (uint128 fees, uint256 newPricePerShare) = _calculateFeeShare(receiver);\n        if (fees > 0) {\n            feeReceiverData[receiver].pendingReward += fees;\n        }\n        feeReceiverData[receiver].lastPricePerShare = newPricePerShare;\n    }\n\n    /// @dev distributeFeeTo\n    /// @notice distribute accrued fees to the msg.sender\n    function distributeFeeTo(address to)\n        public\n        override\n        whenNotPaused\n        returns (uint256 pendingReward)\n    {\n        address receiver = msg.sender;\n\n        require(feeReceiverData[receiver].allocPoint > 0, \"INVALID_RECEIVER\");\n        if (totalFeesReceived == 0) return 0;\n\n        _accrue(receiver);\n\n        pendingReward = feeReceiverData[receiver].pendingReward;\n\n        // transfer feeShare\n        if (pendingReward > 0) {\n            feeReceiverData[receiver].pendingReward = 0;\n            feeAsset.safeTransfer(to, pendingReward);\n        }\n\n        emit FeesTransferred(receiver, pendingReward, block.timestamp);\n    }\n\n    /// @notice pause actions\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice unpause actions\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /// @dev _calculateFeeShare\n    /// @param receiver receiver address\n    function _calculateFeeShare(address receiver)\n        internal\n        view\n        returns (uint128 fees, uint256 newPricePerShare)\n    {\n        newPricePerShare = pricePerShare;\n        uint256 allocPoint = feeReceiverData[receiver].allocPoint;\n\n        if (allocPoint != 0) {\n            uint256 lastPricePerShare = feeReceiverData[receiver].lastPricePerShare;\n            fees = (((allocPoint * (newPricePerShare - lastPricePerShare)) / SHARE_SCALE))\n                .toUint128();\n        }\n    }\n\n    /// @dev setFeeReceiver\n    /// @param feeReceiver address that receive the fee\n    /// @param newAllocPoint percentage of the fees the address receives\n    function _setFeeReceiver(address feeReceiver, uint128 newAllocPoint) internal {\n        FeeReceiver storage config = feeReceiverData[feeReceiver];\n        uint128 currentAllocPoint = config.allocPoint;\n\n        if (currentAllocPoint > 0) {\n            totalAllocPoints -= currentAllocPoint;\n            totalAllocPoints += newAllocPoint;\n            config.allocPoint = newAllocPoint;\n        } else {\n            totalAllocPoints += newAllocPoint;\n            config.allocPoint = newAllocPoint;\n        }\n\n        emit SetFeeReceiver(feeReceiver, currentAllocPoint, newAllocPoint);\n    }\n}\n"
    },
    "contracts/interfaces/IFeeDistribution.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IFeeDistribution {\n    struct FeeReceiver {\n        /// @dev pending reward to be claimed\n        uint128 pendingReward;\n        /// @dev percentage of the fees\n        uint128 allocPoint;\n        /// @dev price per share\n        uint256 lastPricePerShare;\n    }\n\n    event SetFeeReceiver(\n        address indexed receiver,\n        uint256 currentAllocPoint,\n        uint256 newAllocPoint\n    );\n\n    event FeesTransferred(address indexed receiver, uint256 feeShare, uint256 timestamp);\n\n    event RescueFunds(address sender, uint256 amount);\n\n    event ClaimFees(uint256 receivedFees, uint256 totalFeesReceived);\n\n    function distributeFeeTo(address to) external returns (uint256 feeShare);\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/mocks/MockAaveGovernanceWithTokens.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IExecutorWithTimelock} from \"../interfaces/Aave/IExecutorWithTimelock.sol\";\nimport \"hardhat/console.sol\";\n\ncontract MockAaveGovernanceWithTokens {\n    enum ProposalState {\n        Pending,\n        Canceled,\n        Active,\n        Failed,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    struct Vote {\n        bool support;\n        uint248 votingPower;\n    }\n\n    struct ProposalWithoutVotes {\n        uint256 id;\n        address creator;\n        IExecutorWithTimelock executor;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        bool[] withDelegatecalls;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 executionTime;\n        uint256 forVotes;\n        uint256 againstVotes;\n        bool executed;\n        bool canceled;\n        address strategy;\n        bytes32 ipfsHash;\n    }\n\n    mapping(uint256 => uint256) proposals;\n    mapping(uint256 => bool) internal cancelled;\n\n    IERC20 public receiptAaveToken;\n\n    IERC20 public receiptstkAaveToken;\n\n    function setReceiptTokens(IERC20 receiptAaveToken_, IERC20 receiptstkAaveToken_) public {\n        receiptAaveToken = receiptAaveToken_;\n        receiptstkAaveToken = receiptstkAaveToken_;\n    }\n\n    function createProposal(uint256 proposalId) external {\n        proposals[proposalId] = block.number;\n    }\n\n    function submitVote(uint256 proposalId, bool support) external {}\n\n    function getProposalById(uint256 proposalId)\n        external\n        view\n        returns (ProposalWithoutVotes memory p)\n    {\n        p = ProposalWithoutVotes(\n            proposalId,\n            address(0),\n            IExecutorWithTimelock(address(0)),\n            new address[](0),\n            new uint256[](0),\n            new string[](0),\n            new bytes[](0),\n            new bool[](0),\n            proposals[proposalId],\n            proposals[proposalId] + 6232,\n            0,\n            0,\n            0,\n            false,\n            false,\n            address(0),\n            bytes32(0)\n        );\n    }\n\n    function getProposalState(uint256 proposalId) external view returns (ProposalState) {\n        if (cancelled[proposalId] == true) {\n            return ProposalState.Canceled;\n        }\n        return ProposalState.Active;\n    }\n\n    function getGovernanceStrategy() external view returns (address) {\n        return (address(this));\n    }\n\n    function cancel(uint256 proposalId) external {\n        cancelled[proposalId] = true;\n    }\n\n    function getVotingPowerAt(address, uint256) external view returns (uint256) {\n        return receiptAaveToken.totalSupply() + receiptstkAaveToken.totalSupply();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/mocks/MockAaveGovernance.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport {IExecutorWithTimelock} from \"../interfaces/Aave/IExecutorWithTimelock.sol\";\nimport \"hardhat/console.sol\";\n\ncontract MockAaveGovernance {\n    // enum ProposalState {\n    //     Pending,\n    //     Canceled,\n    //     Active,\n    //     Failed,\n    //     Succeeded,\n    //     Queued,\n    //     Expired,\n    //     Executed\n    // }\n    // struct Vote {\n    //     bool support;\n    //     uint248 votingPower;\n    // }\n    // struct ProposalWithoutVotes {\n    //     uint256 id;\n    //     address creator;\n    //     IExecutorWithTimelock executor;\n    //     address[] targets;\n    //     uint256[] values;\n    //     string[] signatures;\n    //     bytes[] calldatas;\n    //     bool[] withDelegatecalls;\n    //     uint256 startBlock;\n    //     uint256 endBlock;\n    //     uint256 executionTime;\n    //     uint256 forVotes;\n    //     uint256 againstVotes;\n    //     bool executed;\n    //     bool canceled;\n    //     address strategy;\n    //     bytes32 ipfsHash;\n    // }\n    // mapping(uint256 => uint256) proposals;\n    // function create(uint256 proposalId) external {\n    //     proposals[proposalId] = block.number;\n    // }\n    // function submitVote(uint256 proposalId, bool support) external {}\n    // function getProposalById(uint256 proposalId)\n    //     external\n    //     view\n    //     returns (ProposalWithoutVotes memory p)\n    // {\n    //     p = ProposalWithoutVotes(\n    //         proposalId,\n    //         address(0),\n    //         IExecutorWithTimelock(address(0)),\n    //         new address[](0),\n    //         new uint256[](0),\n    //         new string[](0),\n    //         new bytes[](0),\n    //         new bool[](0),\n    //         proposals[proposalId],\n    //         proposals[proposalId] + 6232,\n    //         0,\n    //         0,\n    //         0,\n    //         false,\n    //         false,\n    //         address(0),\n    //         bytes32(0)\n    //     );\n    // }\n    // function getProposalState(uint256) external pure returns (ProposalState) {\n    //     return ProposalState.Active;\n    // }\n    // function getGovernanceStrategy() external view returns (address) {\n    //     return (address(this));\n    // }\n    // function getVotingPowerAt(address, uint256) external pure returns (uint256) {\n    //     return 2000e18;\n    // }\n}\n"
    },
    "contracts/test/BribeSingleAssetPool.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/Bribe/IBribeSingleAssetPool.sol\";\n\nabstract contract BribeSingleAssetPool is IBribeSingleAssetPool, ERC20, Ownable {\n    using SafeERC20 for IERC20;\n\n    struct Bid {\n        uint128 highestBid;\n        uint64 endTime;\n        bool support;\n        bool voted;\n        address highestBidder;\n    }\n\n    /// @dev maximum withdraw delay in seconds; 1 week in seconds\n    uint64 internal constant MAX_WITHDRAW_DELAY_SECONDS = 604800;\n\n    /// @dev stakers will deposit governanceToken\n    IERC20 public immutable governanceToken;\n\n    /// @dev bidders will bid with bidAsset\n    IERC20 public immutable bidAsset;\n\n    /// @dev last vote timestamp\n    uint64 public lastVoteEndTime;\n\n    /// @dev delay period for withdrawal after vote ends\n    uint64 public withdrawalDelayPeriodInSeconds;\n\n    /// @dev pending rewards to be distributed\n    uint128 public pendingRewardToBeDistributed;\n\n    /// @dev total bid amount available to claim\n    uint256 public bidIndex;\n\n    /// @dev bidIndex when user claimed lastly\n    mapping(address => uint256) private userToBidIndex;\n\n    /// @dev proposal id to bid\n    mapping(uint256 => Bid) public bids;\n\n    /// @dev blocked proposals\n    mapping(uint256 => bool) public blockedProposals;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        IERC20 _governanceToken,\n        IERC20 _bidAsset,\n        uint64 _withdrawalDelayPeriodInSeconds\n    ) Ownable() ERC20(_name, _symbol) {\n        require(address(_governanceToken) != address(0), \"INVALID_GOV_TOKEN\");\n        require(address(_bidAsset) != address(0), \"INVALID_BID_ASSET\");\n        require(_withdrawalDelayPeriodInSeconds > 0, \"INVALID_DELAY_PERIOD\");\n\n        governanceToken = _governanceToken;\n        bidAsset = _bidAsset;\n        withdrawalDelayPeriodInSeconds = _withdrawalDelayPeriodInSeconds;\n    }\n\n    /// @dev get auction expiration needs an implementation in child contract\n    function getAuctionExpiration(uint256 proposalId) internal view virtual returns (uint256) {}\n\n    ///  @dev deposit governance token\n    /// @param amount amount to deposit\n    /// @notice emit {Deposited} event\n    function deposit(uint256 amount) external override {\n        require(amount > 0, \"INVALID_AMOUNT\");\n\n        governanceToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        // claim pending rewards\n        claimReward();\n\n        _mint(msg.sender, amount);\n\n        emit Deposit(msg.sender, amount, block.timestamp);\n    }\n\n    /// @dev withdraw governance token\n    /// @param amount amount to withdraw\n    /// @notice emit {Withdrawn} event\n    function withdraw(uint256 amount) external override {\n        require(amount > 0, \"INVALID_AMOUNT\");\n        require(balanceOf(msg.sender) >= amount, \"INVALID_BALANCE\");\n        require(\n            block.timestamp >= lastVoteEndTime + withdrawalDelayPeriodInSeconds,\n            \"ACTIVE_DELAY_PERIOD\"\n        );\n        require(pendingRewardToBeDistributed == 0, \"ACTIVE_BID\");\n\n        _burn(msg.sender, amount);\n\n        claimReward();\n\n        governanceToken.safeTransfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount, block.timestamp);\n    }\n\n    /// @dev claim reward\n    function claimReward() public override {\n        uint256 pendingReward = _userPendingRewards(msg.sender);\n        if (pendingReward == 0) return;\n\n        userToBidIndex[msg.sender] = bidIndex;\n        bidAsset.safeTransfer(msg.sender, pendingReward);\n\n        emit RewardClaimed(msg.sender, pendingReward);\n    }\n\n    /// @dev get reward amount for user specified by `user`\n    /// @param user address of user to check balance of\n    function rewardBalanceOf(address user) external view override returns (uint256) {\n        return _userPendingRewards(user);\n    }\n\n    /// @notice call parent's afterVote to perform necessary actions\n    function afterVote() internal virtual {\n        lastVoteEndTime = uint64(block.timestamp);\n    }\n\n    /// @dev place a bid to proposal specified by `proposalId` with `amount` of bid assets\n    /// @param proposalId proposal id\n    /// @param amount amount of bid assets\n    function bid(\n        uint256 proposalId,\n        uint128 amount,\n        bool support\n    ) public virtual {\n        require(blockedProposals[proposalId] == false, \"PROPOSAL_BLOCKED\");\n\n        Bid storage _bid = bids[proposalId];\n        address prevHighestBidder = _bid.highestBidder;\n\n        require(amount > _bid.highestBid, \"LOW_BID\");\n\n        if (prevHighestBidder == address(0)) {\n            uint64 endTime = uint64(getAuctionExpiration(proposalId));\n            require(endTime > block.timestamp, \"EXPIRED_PROPOSAL\");\n            _bid.endTime = endTime;\n        } else {\n            require(_bid.endTime > block.timestamp, \"BID_ENDED\");\n\n            // refund to previous highest bidder\n            pendingRewardToBeDistributed -= _bid.highestBid;\n            bidAsset.safeTransfer(prevHighestBidder, _bid.highestBid);\n        }\n\n        bidAsset.safeTransferFrom(msg.sender, address(this), amount);\n\n        pendingRewardToBeDistributed += amount;\n        _bid.highestBid = amount;\n        _bid.support = support;\n        _bid.highestBidder = msg.sender;\n\n        emit HighestBidIncreased(\n            proposalId,\n            prevHighestBidder,\n            _bid.highestBidder,\n            _bid.highestBid\n        );\n    }\n\n    /// @dev get pending rewards for user and will be reset after claimReward\n    /// @param user user\n    function _userPendingRewards(address user) internal view returns (uint256) {\n        return\n            ((bidIndex - userToBidIndex[user]) * balanceOf(user)) /\n            governanceToken.balanceOf(address(this));\n    }\n\n    /// @dev distribute rewards for the proposal\n    /// @notice called in children's vote function (after bidding process ended)\n    /// @param proposalId id of proposal to distribute rewards fo\n    function distributeRewards(uint256 proposalId) public {\n        Bid storage _bid = bids[proposalId];\n        require(block.timestamp > _bid.endTime, \"BID_ACTIVE\");\n\n        if (_bid.voted) return;\n        pendingRewardToBeDistributed -= _bid.highestBid;\n        bidIndex += _bid.highestBid;\n        _bid.voted = true;\n\n        emit RewardDistributed(proposalId, _bid.highestBid);\n    }\n\n    /// @dev update delay period by owner\n    /// @param _withdrawalDelayPeriodInSeconds new delay period\n    function setDelayPeriod(uint64 _withdrawalDelayPeriodInSeconds) external override onlyOwner {\n        require(_withdrawalDelayPeriodInSeconds > 0, \"INVALID_PERIOD\");\n        require(_withdrawalDelayPeriodInSeconds != withdrawalDelayPeriodInSeconds, \"SAME_PERIOD\");\n        require(_withdrawalDelayPeriodInSeconds <= MAX_WITHDRAW_DELAY_SECONDS, \"EXCEEDS_MAX\");\n\n        withdrawalDelayPeriodInSeconds = _withdrawalDelayPeriodInSeconds;\n    }\n\n    /// @dev block a proposalId from used in the pool\n    /// @param proposalId proposalId\n    function blockProposalId(uint256 proposalId) external onlyOwner {\n        require(blockedProposals[proposalId] == false, \"PROPOSAL_INACTIVE\");\n\n        blockedProposals[proposalId] = true;\n\n        // check if the proposalId has any bids\n        Bid storage currentBid = bids[proposalId];\n\n        // if there is any current highest bidder\n        // and the reward has not been distributed refund the bidder\n        uint128 highestBid = currentBid.highestBid;\n        if (highestBid > 0 && !currentBid.voted) {\n            pendingRewardToBeDistributed -= highestBid;\n            bidAsset.safeTransfer(currentBid.highestBidder, highestBid);\n            currentBid.highestBidder = address(0);\n            currentBid.highestBid = 0;\n        }\n\n        emit BlockProposalId(proposalId, block.timestamp);\n    }\n\n    /// @dev unblock a proposalId from used in the pool\n    /// @param proposalId proposalId\n    function unblockProposalId(uint256 proposalId) external onlyOwner {\n        require(blockedProposals[proposalId] == true, \"PROPOSAL_ACTIVE\");\n\n        blockedProposals[proposalId] = false;\n\n        emit UnblockProposalId(proposalId, block.timestamp);\n    }\n}\n"
    },
    "contracts/interfaces/Bribe/IBribeSingleAssetPool.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.4;\n\ninterface IBribeSingleAssetPool {\n    event Deposit(address indexed user, uint256 amount, uint256 time);\n\n    event Withdraw(address indexed user, uint256 amount, uint256 time);\n\n    event RewardClaimed(address indexed user, uint256 amount);\n\n    event RewardDistributed(uint256 proposalId, uint256 amount);\n\n    event HighestBidIncreased(\n        uint256 indexed proposalId,\n        address indexed prevHighestBidder,\n        address indexed highestBidder,\n        uint256 highestBid\n    );\n\n    event BlockProposalId(uint256 indexed proposalId, uint256 timestamp);\n\n    event UnblockProposalId(uint256 indexed proposalId, uint256 timestamp);\n\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function claimReward() external;\n\n    function rewardBalanceOf(address user) external view returns (uint256);\n\n    function setDelayPeriod(uint64 _delayPeriod) external;\n}\n"
    },
    "contracts/test/SampleSingleAsset.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\n\npragma solidity 0.8.4;\n\nimport \"./BribeSingleAssetPool.sol\";\n\ncontract SampleSingleAsset is BribeSingleAssetPool {\n    uint256 public constant expiration = 60;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        IERC20 _governanceToken,\n        IERC20 _bidAsset,\n        uint64 _delayPeriod\n    ) BribeSingleAssetPool(_name, _symbol, _governanceToken, _bidAsset, _delayPeriod) {}\n\n    function getAuctionExpiration(\n        uint256 /*proposalId*/\n    ) internal view override returns (uint256) {\n        return block.timestamp + expiration;\n    }\n\n    function vote(\n        uint256 proposalId,\n        bool /*support*/\n    ) external {\n        distributeRewards(proposalId);\n        afterVote();\n    }\n}\n"
    },
    "contracts/staking/Dividends.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"../interfaces/IDividends.sol\";\nimport \"../interfaces/IFeeDistribution.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n///\n/// @title Dividends\n/// @author contact@bribe.xyz\n/// @notice\n///\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract Dividends is IDividends, ERC20Votes, Ownable, Pausable, Multicall {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    /// @dev minimum deposit to accrue\n    uint256 private constant MINIMUM_DEPOSIT = 100 * 1e18;\n\n    /// @dev share scale\n    uint256 private constant SHARE_SCALE = 1e12;\n\n    /// @dev reward asset\n    IERC20 public immutable rewardAsset;\n\n    /// @dev stake asset\n    IERC20 public immutable stakeAsset;\n\n    /// @dev feeDistribution\n    address public feeDistribution;\n\n    /// @dev totalDividendsReceived\n    uint128 public totalDividendsReceived;\n\n    /// @dev totalStaked\n    uint128 public totalStaked;\n\n    /// @dev price peer share\n    uint128 public pricePerShare;\n\n    struct UserInfo {\n        uint128 pendingReward;\n        uint128 lastPricePerShare;\n    }\n\n    /// @dev userRewards\n    mapping(address => UserInfo) public userRewards;\n\n    constructor(\n        address rewardAsset_,\n        address stakeAsset_,\n        address feeDistribution_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) ERC20Permit(name_) {\n        require(rewardAsset_ != address(0), \"INVALID_ASSET\");\n        require(stakeAsset_ != address(0), \"INVALID_STAKE_ASSET\");\n        require(feeDistribution_ != address(0), \"INVALID_FEE_ASSET\");\n\n        rewardAsset = IERC20(rewardAsset_);\n        stakeAsset = IERC20(stakeAsset_);\n        feeDistribution = feeDistribution_;\n    }\n\n    /// @dev accrueDividend\n    /// @notice calls the fee distribution contract to claim pending dividend\n    function accrueDividend() public whenNotPaused {\n        _accrueDividendInternal();\n    }\n\n    function _accrueDividendInternal() internal {\n        uint256 prevBalance = rewardAsset.balanceOf(address(this));\n\n        uint256 amount = IFeeDistribution(feeDistribution).distributeFeeTo(address(this));\n\n        if (amount == 0) return;\n\n        // assert that the amount was transferred\n        require(\n            rewardAsset.balanceOf(address(this)) - prevBalance >= amount,\n            \"INVALID_DISTRIBUTION\"\n        );\n\n        totalDividendsReceived += amount.toUint128();\n        uint256 totalStaked_ = totalStaked > 0 ? totalStaked : 1;\n        pricePerShare += ((amount * SHARE_SCALE) / totalStaked_).toUint128();\n\n        emit DistributeDividend(amount);\n    }\n\n    /// @dev deposit\n    /// @param to address to send\n    /// @param amount Amount user wants do stake\n    /// @param update to distribute pending dividends or not\n    function stake(\n        address to,\n        uint128 amount,\n        bool update\n    ) external override whenNotPaused {\n        require(to != address(0), \"INVALID_TO\");\n        require(amount != 0, \"INVALID_AMOUNT\");\n\n        if (update || amount > MINIMUM_DEPOSIT || msg.sender != tx.origin) {\n            _accrueDividendInternal();\n        }\n\n        _accrue(to);\n\n        _mint(to, amount);\n\n        totalStaked += amount;\n\n        stakeAsset.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(address(this), msg.sender, to, amount);\n    }\n\n    /// @dev _accrue\n    /// @param user user address to accrue\n    function _accrue(address user) internal {\n        (uint128 pendingReward, uint128 newPricePerShare) = _calculateUserDividend(user);\n        userRewards[user].pendingReward += pendingReward;\n        userRewards[user].lastPricePerShare = newPricePerShare;\n    }\n\n    /// @dev _beforeTokenTransfer hook\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /*amount*/\n    ) internal override {\n        if (from != address(0)) {\n            _accrue(from);\n        }\n\n        if (to != address(0)) {\n            _accrue(to);\n        }\n    }\n\n    /// @dev _calculateUserDividend\n    /// @param user User to calculate their dividend\n    function _calculateUserDividend(address user)\n        internal\n        view\n        returns (uint128 pendingReward, uint128 newPricePerShare)\n    {\n        uint256 lastPricePerShare = userRewards[user].lastPricePerShare;\n        uint128 amount = balanceOf(user).toUint128();\n\n        newPricePerShare = pricePerShare;\n        if (totalDividendsReceived > 0 && amount > 0) {\n            pendingReward = ((amount * (newPricePerShare - lastPricePerShare)) / SHARE_SCALE)\n                .toUint128();\n        }\n    }\n\n    /// @dev unstake\n    /// @param amount amount of tokens to unstake\n    /// @param update Either to claim pending dividend from fee distribution contract\n    function unstake(uint128 amount, bool update) external {\n        if (update) _accrueDividendInternal();\n\n        _accrue(msg.sender);\n\n        _burn(msg.sender, amount);\n        totalStaked -= amount;\n\n        stakeAsset.safeTransfer(msg.sender, amount);\n\n        emit Unstake(msg.sender, amount);\n    }\n\n    /// @dev claimUserDividend\n    /// @param update update\n    function claimUserDividend(bool update) public whenNotPaused {\n        if (update) _accrueDividendInternal();\n\n        _accrue(msg.sender);\n\n        uint256 pendingReward = userRewards[msg.sender].pendingReward;\n        if (pendingReward > 0) {\n            userRewards[msg.sender].pendingReward = 0;\n            rewardAsset.safeTransfer(msg.sender, pendingReward);\n        }\n\n        emit ClaimDividend(msg.sender, pendingReward);\n    }\n\n    /// @dev rescueFunds\n    /// @param asset asset to rescue funds off\n    function rescueFunds(IERC20 asset) external onlyOwner {\n        require(asset != stakeAsset, \"INVALID_ASSET\");\n\n        uint256 balance = asset.balanceOf(address(this));\n\n        asset.transfer(msg.sender, balance);\n\n        emit RescueFunds(balance);\n    }\n\n    /// @notice pause actions\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice unpause actions\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /// @notice setFeeDistributor\n    function setFeeDistributor(address newFeeDistribution) external onlyOwner {\n        require(newFeeDistribution != address(0), \"INVALID_DISTRIBUTOR\");\n\n        feeDistribution = newFeeDistribution;\n\n        emit UpdateFeeDistributor(newFeeDistribution);\n    }\n\n    /// @dev dividendOf\n    /// @param user address of user\n    function dividendOf(address user) external view returns (uint256 dividend) {\n        (uint128 pendingReward, ) = _calculateUserDividend(user);\n        dividend = userRewards[user].pendingReward + pendingReward;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20Votes is ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}\n"
    },
    "contracts/interfaces/IDividends.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IDividends {\n    event Stake(\n        address indexed dividend,\n        address indexed sender,\n        address indexed to,\n        uint256 amount\n    );\n\n    event Unstake(address indexed user, uint256 amount);\n\n    event ClaimDividend(address indexed user, uint256 amount);\n\n    event RescueFunds(uint256 balance);\n\n    event DistributeDividend(uint256 amount);\n\n    event UpdateFeeDistributor(address newFeeDistribution);\n\n    function stake(\n        address to,\n        uint128 amount,\n        bool update\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/helper/BribeStakeHelper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IBribeExecutor.sol\";\nimport \"../interfaces/IDividends.sol\";\n\ncontract BribeStakeHelper is IBribeExecutor {\n    using SafeERC20 for IERC20;\n\n    /// @dev stake token\n    IERC20 public immutable bribeToken;\n\n    constructor(IERC20 bribeToken_) {\n        bribeToken = bribeToken_;\n    }\n\n    /// @dev execute Stakes the bribe token\n    ///\n    /// NOTE: Do not transfer tokens to this contract directly\n    /// without calling execute function\n    ///\n    ///\n    /// @param user user address\n    /// @param amount amount transferred to the contract\n    function execute(\n        address user,\n        uint256 amount,\n        bytes calldata data\n    ) external override {\n        address staking = abi.decode(data, (address));\n        bribeToken.safeApprove(address(staking), amount);\n        IDividends(staking).stake(user, uint128(amount), false);\n    }\n}\n"
    },
    "contracts/staking/LiquidityMining.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../libraries/SignedSafeMath.sol\";\nimport \"../token/BribeToken.sol\";\n\n/// @title LiquidityMining\n/// @notice\n/// @dev\ncontract LiquidityMining is Ownable {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n    using SignedSafeMath for int256;\n\n    /// @notice Info of each masterchef user.\n    /// `amount` LP token amount the user has provided.\n    /// `rewardDebt` The amount of BRB entitled to the user.\n    /// `locked` locked for the first 3 months of liquidity mining, enjoy a 2 times boost\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    /// @notice Info of each LM pool.\n    /// `allocPoint` The amount of allocation points assigned to the pool.\n    /// Also known as the amount of BRB to distribute per block.\n    struct PoolInfo {\n        uint256 accInstrumentalPerShare;\n        uint64 lastRewardBlock;\n        uint64 end;\n        bool locked;\n        uint256 instrumentalPerBlock;\n        uint256 supply;\n    }\n    /// @notice Address of BRB contract.\n    IERC20 public immutable BRB;\n    /// @notice keep track of how much rewards needs to be distributed\n    uint256 internal claimableRewards = 0;\n    /// @notice Info of each LM pool.\n    PoolInfo[] public poolInfo;\n    /// @notice Address of the LP token for each LiquidityMining pool.\n    IERC20[] public lpToken;\n\n    /// @notice Info of each user that stakes LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n    /// @notice\n    uint256 private constant ACC_INST_PRECISION = 1e12;\n\n    // @notice Pool expiration in blocks (4 months at an average of 13 seconds per block)\n    uint256 private constant POOL_EXPIRATION = 800_000;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount,\n        address indexed to\n    );\n    event Harvest(address indexed user, uint256 indexed pid, uint256 amount);\n    event LogPoolAddition(\n        uint256 indexed pid,\n        uint256 instrumentalPerBlock,\n        IERC20 indexed lpToken\n    );\n    event LogSetPool(uint256 indexed pid, uint256 instrumentalPerBlock);\n    event LogUpdatePool(\n        uint256 indexed pid,\n        uint64 lastRewardBlock,\n        uint256 lpSupply,\n        uint256 accInstrumentalPerShare\n    );\n    event LogInit();\n\n    /// @dev\n    modifier onlyUnlocked(uint256 pid) {\n        require(_isLocked(pid) == false, \"LiquidityMining: ONLY_UNLOCKED\");\n        _;\n    }\n\n    /// @notice\n    /// @dev\n    /// @param _bribe ()\n    constructor(IERC20 _bribe) {\n        BRB = _bribe;\n    }\n\n    function _isLocked(uint256 pid) internal view returns (bool) {\n        PoolInfo memory pool = poolInfo[pid];\n        return (pool.locked == true && pool.end > block.number);\n    }\n\n    function _arePoolExpired() internal view returns (bool) {\n        uint256 end = 0;\n        for (uint256 i = 0; i < poolInfo.length; ++i) {\n            end = poolInfo[i].end > end ? poolInfo[i].end : end;\n        }\n        return block.number > end + POOL_EXPIRATION;\n    }\n\n    /// @notice Returns the number of LM pools.\n    /// @notice\n    /// @dev\n    /// @return pools (uint256)\n    function poolLength() public view returns (uint256 pools) {\n        pools = poolInfo.length;\n    }\n\n    /// @notice Add a new LP to the pool. Can only be called by the owner.\n    function add(\n        uint256 instrumentalPerBlock,\n        IERC20 _lpToken,\n        uint64 end,\n        bool locked\n    ) public onlyOwner {\n        uint256 maxRewards = uint256(end).sub(block.number).mul(instrumentalPerBlock);\n        require(\n            BRB.balanceOf(address(this)) >= maxRewards + claimableRewards,\n            \"LM: Insufficient funds\"\n        );\n        claimableRewards += maxRewards;\n\n        lpToken.push(_lpToken);\n\n        poolInfo.push(\n            PoolInfo({\n                accInstrumentalPerShare: 0,\n                lastRewardBlock: uint64(block.number),\n                end: end,\n                locked: locked,\n                instrumentalPerBlock: instrumentalPerBlock,\n                supply: 0\n            })\n        );\n        emit LogPoolAddition(lpToken.length.sub(1), instrumentalPerBlock, _lpToken);\n    }\n\n    /// @notice Update the given pool's BRB allocation point. Can only be called by the owner.\n    /// @param _pid The index of the pool. See `poolInfo`.\n    /// @param _instrumentalPerBlock New rewards of the pool.\n    /// disabled for now\n    // function set(uint256 _pid, uint256 _instrumentalPerBlock) public onlyOwner {\n    //     poolInfo[_pid].instrumentalPerBlock = _instrumentalPerBlock;\n    //     emit LogSetPool(_pid, _instrumentalPerBlock);\n    // }\n\n    /// @notice View function to see pending BRB on frontend.\n    /// @param _pid The index of the pool. See `poolInfo`.\n    /// @param _user Address of user.\n    /// @return pending BRB reward for a given user.\n    function pendingInstrumental(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256 pending)\n    {\n        PoolInfo memory pool = poolInfo[_pid];\n        UserInfo memory user = userInfo[_pid][_user];\n        uint256 accInstrumentalPerShare = pool.accInstrumentalPerShare;\n        if (block.number > pool.lastRewardBlock && pool.supply != 0) {\n            uint256 lastValidBlock = block.number > pool.end ? pool.end : block.number;\n            uint256 blocks = lastValidBlock.sub(pool.lastRewardBlock);\n            uint256 sushiReward = blocks.mul(pool.instrumentalPerBlock);\n            accInstrumentalPerShare = accInstrumentalPerShare.add(\n                sushiReward.mul(ACC_INST_PRECISION) / pool.supply\n            );\n        }\n        pending = int256(user.amount.mul(accInstrumentalPerShare) / ACC_INST_PRECISION)\n            .sub(user.rewardDebt)\n            .toUInt256();\n    }\n\n    function withdrawLeftovers() public onlyOwner {\n        require(_arePoolExpired() == true, \"LM: Pools are not expired\");\n        BRB.transfer(msg.sender, BRB.balanceOf(address(this)));\n    }\n\n    /// @notice Update reward variables for all pools. Be careful of gas spending!\n    /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\n    function massUpdatePools(uint256[] calldata pids) external {\n        uint256 len = pids.length;\n        for (uint256 i = 0; i < len; ++i) {\n            updatePool(pids[i]);\n        }\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @return pool Returns the pool that was updated.\n    function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\n        pool = poolInfo[pid];\n        if (block.number > pool.lastRewardBlock && pool.lastRewardBlock < pool.end) {\n            uint256 lastValidBlock = block.number > pool.end ? pool.end : block.number;\n            if (pool.supply > 0) {\n                uint256 blocks = lastValidBlock.sub(pool.lastRewardBlock);\n                uint256 sushiReward = blocks.mul(pool.instrumentalPerBlock);\n                // mint additional tokens @todo should I mint them or not?\n                // BRB.mint(address(this), sushiReward);\n                uint256 rewardFactor = sushiReward.mul(ACC_INST_PRECISION) / pool.supply;\n                pool.accInstrumentalPerShare = pool.accInstrumentalPerShare.add(rewardFactor);\n                pool.lastRewardBlock = uint64(lastValidBlock);\n            }\n            poolInfo[pid] = pool;\n            emit LogUpdatePool(\n                pid,\n                pool.lastRewardBlock,\n                pool.supply,\n                pool.accInstrumentalPerShare\n            );\n        }\n    }\n\n    /// @notice Deposit LP tokens to LM for BRB allocation.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param amount LP token amount to deposit.\n    /// @param to The receiver of `amount` deposit benefit.\n    function deposit(\n        uint256 pid,\n        uint256 amount,\n        address to\n    ) public {\n        updatePool(pid);\n        UserInfo storage user = userInfo[pid][to];\n        PoolInfo storage pool = poolInfo[pid];\n\n        // Effects\n        user.amount = user.amount.add(amount);\n        user.rewardDebt = user.rewardDebt.add(\n            int256(amount.mul(pool.accInstrumentalPerShare) / ACC_INST_PRECISION)\n        );\n        pool.supply = pool.supply.add(amount);\n\n        lpToken[pid].safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Deposit(msg.sender, pid, amount, to);\n    }\n\n    /// @notice Withdraw LP tokens from LM.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param amount LP token amount to withdraw.\n    /// @param to Receiver of the LP tokens.\n    function withdraw(\n        uint256 pid,\n        uint256 amount,\n        address to\n    ) public onlyUnlocked(pid) {\n        updatePool(pid);\n        UserInfo storage user = userInfo[pid][msg.sender];\n        PoolInfo storage pool = poolInfo[pid];\n        // Effects\n        user.rewardDebt = user.rewardDebt.sub(\n            int256(amount.mul(pool.accInstrumentalPerShare) / ACC_INST_PRECISION)\n        );\n        user.amount = user.amount.sub(amount);\n        pool.supply = pool.supply.sub(amount);\n\n        lpToken[pid].safeTransfer(to, amount);\n\n        emit Withdraw(msg.sender, pid, amount, to);\n    }\n\n    /// @notice Harvest proceeds for transaction sender to `to`.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param to Receiver of BRB rewards.\n    function harvest(uint256 pid, address to) public onlyUnlocked(pid) {\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo storage user = userInfo[pid][msg.sender];\n        require(_arePoolExpired() == false, \"LM: Pool has expired\");\n        int256 accumulatedInstrumental = int256(\n            user.amount.mul(pool.accInstrumentalPerShare) / ACC_INST_PRECISION\n        );\n        uint256 _pendingRewards = accumulatedInstrumental.sub(user.rewardDebt).toUInt256();\n\n        // Effects\n        user.rewardDebt = accumulatedInstrumental;\n\n        // Interactions\n        if (_pendingRewards != 0) {\n            claimableRewards -= _pendingRewards;\n            BRB.transfer(to, _pendingRewards);\n        }\n\n        emit Harvest(msg.sender, pid, _pendingRewards);\n    }\n\n    /// @notice Withdraw LP tokens from LM and harvest proceeds for transaction sender to `to`.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param amount LP token amount to withdraw.\n    /// @param to Receiver of the LP tokens and BRB rewards.\n    function withdrawAndHarvest(\n        uint256 pid,\n        uint256 amount,\n        address to\n    ) public onlyUnlocked(pid) {\n        updatePool(pid);\n        UserInfo storage user = userInfo[pid][msg.sender];\n        PoolInfo storage pool = poolInfo[pid];\n        require(_arePoolExpired() == false, \"LM: Pool has expired\");\n        int256 accumulatedInstrumental = int256(\n            user.amount.mul(pool.accInstrumentalPerShare) / ACC_INST_PRECISION\n        );\n        uint256 _pendingReward = accumulatedInstrumental.sub(user.rewardDebt).toUInt256();\n\n        // Effects\n        user.rewardDebt = accumulatedInstrumental.sub(\n            int256(amount.mul(pool.accInstrumentalPerShare) / ACC_INST_PRECISION)\n        );\n        user.amount = user.amount.sub(amount);\n        pool.supply = pool.supply.sub(amount);\n\n        // Interactions\n        claimableRewards -= _pendingReward;\n        BRB.transfer(to, _pendingReward);\n\n        lpToken[pid].safeTransfer(to, amount);\n\n        emit Withdraw(msg.sender, pid, amount, to);\n        emit Harvest(msg.sender, pid, _pendingReward);\n    }\n\n    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param to Receiver of the LP tokens.\n    function emergencyWithdraw(uint256 pid, address to) public onlyUnlocked(pid) {\n        UserInfo storage user = userInfo[pid][msg.sender];\n        PoolInfo storage pool = poolInfo[pid];\n        uint256 amount = user.amount;\n        user.amount = 0;\n        user.rewardDebt = 0;\n        pool.supply = pool.supply.sub(amount);\n\n        // Note: transfer can fail or succeed if `amount` is zero.\n        lpToken[pid].safeTransfer(to, amount);\n        emit EmergencyWithdraw(msg.sender, pid, amount, to);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/libraries/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary SignedSafeMath {\n    int256 private constant _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function toUInt256(int256 a) internal pure returns (uint256) {\n        require(a >= 0, \"Integer < 0\");\n        return uint256(a);\n    }\n}\n"
    },
    "contracts/token/BribeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n///\n/// @title Bribe ERC20 Token\n/// @author contact@bribe.xyz\n/// @notice\n///\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract BribeToken is ERC20Permit {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 totalSupply_\n    ) ERC20(name_, symbol_) ERC20Permit(name_) {\n        _mint(msg.sender, totalSupply_);\n    }\n}\n"
    },
    "contracts/helper/MIMBidHelper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\nimport \"../interfaces/IAavePool.sol\";\nimport \"../interfaces/Curve/ICurvePool.sol\";\n\n/**\n * @notice Bid Helper. Contract to Bid to aave pool using other tokens\n */\ncontract AaveMIMBidHelperV1 {\n    using SafeERC20 for IERC20;\n\n    struct CurvePoolConfig {\n        ICurvePool curvePool; // address of the curve pool\n        int128 xTokenIndex; // i token index for the curve pool\n        int128 yTokenIndex; // j token index for the curve pool\n    }\n\n    struct Bid {\n        IERC20 token; // token to swap from curve pool\n        uint256 amount; // amount of tokens\n        uint256 minUSDCToReceive; // minimum USDC to receive after swapping from the pool\n        uint256 proposalId; // proposal to bid against\n        bool support; // support for the proposal\n        CurvePoolConfig curvePoolConfig; // curve pool details\n    }\n\n    /**\n     * @notice Event emitted when Bid is submitted from the helper contract\n     */\n    event BidWithOtherAsset(\n        IERC20 indexed token,\n        address indexed bidder,\n        uint256 proposalId,\n        bool support,\n        uint256 amountInBidAsset,\n        uint256 usdcPlacedInBid\n    );\n\n    /**\n     * @notice Address of the USDC tokens\n     */\n    IERC20 public immutable usdcToken;\n    /**\n     * @notice Address of the Aave Bribe Pool\n     */\n    IAavePool public immutable aaveBribePool;\n\n    /**\n     * @notice Constructor\n     * @param _usdcToken Address of the USDC token\n     * @param _aaveBribePool Address of the Aave Bribe Pool\n     */\n    constructor(IERC20 _usdcToken, IAavePool _aaveBribePool) {\n        usdcToken = _usdcToken;\n        aaveBribePool = _aaveBribePool;\n    }\n\n    /**\n     * @notice Swap tokens from curve and then bid against Aave Pool\n     * @param bid Details of the bid\n     * @return amount bid to the aave pool\n     */\n    function curveSwapAssetBid(Bid calldata bid) external returns (uint256) {\n        return\n            _curveSwapAssetBid(\n                bid.token,\n                bid.amount,\n                bid.minUSDCToReceive,\n                bid.proposalId,\n                bid.support,\n                bid.curvePoolConfig\n            );\n    }\n\n    /**\n     * @notice Swap tokens from curve and then bid against Aave Pool using permit function from ERC20Permit\n     * @param bid Details of the bid\n     * @return amount bid to the aave pool\n     */\n    function curveSwapAssetBidWithPermit(\n        Bid calldata bid,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        IERC20Permit(address(bid.token)).permit(owner, spender, value, deadline, v, r, s);\n        return\n            _curveSwapAssetBid(\n                bid.token,\n                bid.amount,\n                bid.minUSDCToReceive,\n                bid.proposalId,\n                bid.support,\n                bid.curvePoolConfig\n            );\n    }\n\n    /**\n     * @notice Internal functions to place the bid\n     * @param _token address of the token to swap\n     * @param _amount amount of tokens to swap\n     * @param _minUSDCToReceive Minimum number of USDC to receive after swapping\n     * @param proposalId proposal to bid\n     * @param support Support for the proposal\n     * @return amount bid to the aave pool\n     */\n    function _curveSwapAssetBid(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _minUSDCToReceive,\n        uint256 proposalId,\n        bool support,\n        CurvePoolConfig calldata curvePoolConfig\n    ) internal returns (uint256) {\n        require(_minUSDCToReceive != 0, \"Min USDT to receive should be non zero\");\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n        _token.safeApprove(address(curvePoolConfig.curvePool), _amount);\n\n        uint256 tokensReceived = curvePoolConfig.curvePool.exchange_underlying(\n            curvePoolConfig.xTokenIndex,\n            curvePoolConfig.yTokenIndex,\n            _amount,\n            _minUSDCToReceive\n        );\n        require(\n            tokensReceived >= _minUSDCToReceive,\n            \"amount received should be more than min usdc requested\"\n        );\n\n        usdcToken.approve(address(aaveBribePool), tokensReceived);\n        aaveBribePool.bid(msg.sender, proposalId, uint128(tokensReceived), support);\n        emit BidWithOtherAsset(_token, msg.sender, proposalId, support, _amount, tokensReceived);\n        return tokensReceived;\n    }\n}\n"
    },
    "contracts/interfaces/Curve/ICurvePool.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ICurvePool {\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        address _receiver\n    ) external returns (uint256);\n}\n"
    },
    "contracts/mocks/MockPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockPool {\n    IERC20 public asset;\n    bool transfer;\n\n    constructor(address asset_, bool transfer_) {\n        asset = IERC20(asset_);\n        transfer = transfer_;\n    }\n\n    function withdrawFees() public returns (uint256 amount) {\n        amount = asset.balanceOf(address(this));\n        if (transfer) {\n            asset.transfer(msg.sender, amount);\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockFeeDistributor {\n    IERC20 public asset;\n    bool transfer;\n\n    constructor(address asset_, bool transfer_) {\n        asset = IERC20(asset_);\n        transfer = transfer_;\n    }\n\n    function distributeFeeTo() public view returns (uint256 amount) {\n        amount = asset.balanceOf(address(this));\n        // if (transfer) {\n        //     asset.transfer(msg.sender, amount);\n        // }\n    }\n}\n"
    },
    "contracts/mocks/Erc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Erc20 is ERC20 {\n    mapping(address => uint256) private rewards;\n\n    constructor() ERC20(\"Testing\", \"TEST\") {}\n\n    function mint(uint256 amount) external {\n        _mint(msg.sender, amount);\n    }\n\n    function mintTo(address sender, uint256 amount) external {\n        _mint(sender, amount);\n    }\n\n    function getTotalRewardsBalance(address staker) external view returns (uint256) {\n        return rewards[staker];\n    }\n\n    function setReward(address to, uint256 value) external {\n        _mint(to, value);\n        rewards[to] = value;\n    }\n\n    function claimRewards(\n        address, /*to*/\n        uint256 amount\n    ) external {\n        rewards[msg.sender] -= amount;\n    }\n}\n"
    },
    "contracts/mocks/USDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"./Erc20.sol\";\n\ncontract USDC is Erc20 {\n    constructor() Erc20() {}\n}\n"
    },
    "contracts/mocks/MockStkAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Erc20.sol\";\n\ncontract MockStkAave is Erc20 {}\n"
    },
    "contracts/mocks/MockAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Erc20.sol\";\n\ncontract MockAave is Erc20 {}\n"
    },
    "contracts/mocks/BidAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"./Erc20.sol\";\n\ncontract BidAsset is Erc20 {\n    constructor() Erc20() {}\n}\n"
    },
    "contracts/WrapperToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IWrapperToken.sol\";\nimport \"./interfaces/IERC20Details.sol\";\nimport \"hardhat/console.sol\";\n\ncontract WrapperToken is ERC20Upgradeable, OwnableUpgradeable, IWrapperToken {\n    struct Snapshot {\n        uint256[] blockNumbers;\n        uint256[] amounts;\n    }\n\n    /// @dev underlying asset\n    address public underlying;\n\n    /// @dev account balance snapshots\n    mapping(address => Snapshot) private _accountBalanceSnapshots;\n\n    function initialize(address underlying_) external override initializer {\n        underlying = underlying_;\n\n        __Ownable_init();\n\n        __ERC20_init(\n            string(abi.encodePacked(\"bribe-\", IERC20Details(address(underlying_)).name())),\n            string(abi.encodePacked(\"br\", IERC20Details(address(underlying_)).symbol()))\n        );\n    }\n\n    function mint(address user, uint256 amount) external override onlyOwner {\n        _mint(user, amount);\n    }\n\n    /// @dev burn tokens\n    function burn(address user, uint256 amount) external override onlyOwner {\n        _burn(user, amount);\n    }\n\n    function getAccountSnapshotCount(address user) public view returns (uint256) {\n        return _accountBalanceSnapshots[user].blockNumbers.length;\n    }\n\n    function getAccountSnapshot(address user)\n        external\n        view\n        override\n        returns (uint256[] memory, uint256[] memory)\n    {\n        return (\n            _accountBalanceSnapshots[user].blockNumbers,\n            _accountBalanceSnapshots[user].amounts\n        );\n    }\n\n    /// @dev _beforeTokenTransfer\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        if (from == to) {\n            return;\n        }\n\n        if (from != address(0)) {\n            uint256 currentBalance = balanceOf(from);\n            _updateAccountSnapshot(from, currentBalance, currentBalance - amount);\n        }\n\n        if (to != address(0)) {\n            uint256 currentBalance = balanceOf(to);\n            _updateAccountSnapshot(to, currentBalance, currentBalance + amount);\n        }\n    }\n\n    function _updateAccountSnapshot(\n        address account,\n        uint256 oldValue,\n        uint256 newValue\n    ) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], newValue);\n\n        emit UpdateSnapshot(account, oldValue, newValue, block.timestamp);\n    }\n\n    function _updateSnapshot(Snapshot storage userSnapshots, uint256 newValue) internal {\n        uint256 currrentBlockNumber = block.number;\n\n        uint256 size = userSnapshots.blockNumbers.length;\n\n        // multiple snapshots in the current block\n        if (size > 0 && userSnapshots.blockNumbers[size - 1] == currrentBlockNumber) {\n            userSnapshots.amounts[size - 1] = newValue;\n        } else {\n            userSnapshots.blockNumbers.push(currrentBlockNumber);\n            userSnapshots.amounts.push(newValue);\n        }\n    }\n\n    /// @dev getDepositAt user deposit at blockNumber or closest to blockNumber\n    function getDepositAt(address user, uint256 blockNumber)\n        external\n        view\n        override\n        returns (uint256 amount)\n    {\n        Snapshot storage userSnapshots = _accountBalanceSnapshots[user];\n        uint256 size = userSnapshots.blockNumbers.length;\n\n        if (size == 0) return 0;\n\n        // check if the user latest and least deposit are within range of blockNumber\n        if (userSnapshots.blockNumbers[0] > blockNumber) return 0;\n        if (userSnapshots.blockNumbers[size - 1] <= blockNumber)\n            return userSnapshots.amounts[size - 1];\n\n        return _searchByBlockNumber(userSnapshots, size, blockNumber);\n    }\n\n    /// @dev _searchByProposalId searches the reward snapshot by blockNumber. Uses binary search.\n    /// @param snapshot reward\n    /// @param blockNumber proposalId\n    function _searchByBlockNumber(\n        Snapshot storage snapshot,\n        uint256 snapshotSize,\n        uint256 blockNumber\n    ) internal view returns (uint256 amount) {\n        uint256 lower = 0;\n        uint256 upper = snapshotSize - 1;\n\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            if (snapshot.blockNumbers[center] == blockNumber) {\n                return snapshot.amounts[center];\n            } else if (snapshot.blockNumbers[center] < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n\n        return snapshot.amounts[lower];\n    }\n\n    /// @dev _transfer Transfer not allowed\n    function _transfer(\n        address, /*sender*/\n        address, /*recipient*/\n        uint256 /*amount*/\n    ) internal pure override {\n        revert(\"TRANSFER_NOT_ALLOWED\");\n    }\n\n    /// @dev approve Approve not allowed\n    function _approve(\n        address, /*owner*/\n        address, /*spender*/\n        uint256 /*amount*/\n    ) internal pure override(ERC20Upgradeable) {\n        revert(\"APPROVE_NOT_ALLOWED\");\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/StkAaveWrapperToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport \"./WrapperToken.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n///\n/// @title StkAaveWrapperToken\n/// @author contact@bribe.xyz\n/// @notice\n///\n////////////////////////////////////////////////////////////////////////////////////////////\ncontract StkAaveWrapperToken is WrapperToken {\n\n}\n"
    },
    "contracts/AaveWrapperToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\nimport \"./WrapperToken.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n///\n/// @title AaveWrapperToken\n/// @author contact@bribe.xyz\n/// @notice\n///\n////////////////////////////////////////////////////////////////////////////////////////////\ncontract AaveWrapperToken is WrapperToken {\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}